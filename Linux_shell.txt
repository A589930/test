
count no of lines in file : wc -l filename
count no of words in file : wc -w filename

ls = echo *  // both are same

Sticky BIT 
https://www.thegeekstuff.com/2013/02/sticky-bit/
linuxnix.com/sticky-bit-set-linux/


mtime : ls -l : show the last update to file content, it does not udpate with change in permission or owner
atime : ls -lu : shows the last file accessed time 
ctime : ls -lc : it changes when u change the files ownership or access permission .

file creation time : 
1) find files inode number by following command :
ls -i file.txt
2)find partition name on which your filesystem is residing by df -hk command
df -hk  (for example /dev/sda1)
3) debugfs -R 'stat <inode number>' /dev/sda1




date -s "27 AUGUST 2018 15:44:00"  // set date 
set cron every 10 minutes : */10 * * * * command
at 11 Am nad 4 PM : 		00 11,16 * * * command 
from 9 AM to 6 PM : 		00 09-18 * * *
from 9 AM to 6 PM ( weekdays only)		: 00 09-18 * * 1-5
means every 2 minuts in first  10 minutes : 0-10/2 * * * *
@yearly  : 0 0 1 1 *
@daily   : 0 0 * * *
@hourly  : 0 * * * *
@reboot  runs at startup

write a shell script to monitor disk space usage :
{
df -hk | grep tmp > /tmp/vij/s
var=`cat /tmp/vij/s | awk '{ print $5 }'`
var1=`echo"${var::-1}"`
echo $var1
}  // this script is not completed still

remove blank line from file
cat filename | grep -v "^$" > temp_file

[ram2@atrcxb2957 t]$ cat t  //create 50 users 
#!/bin/bash

for i in ` cat ./a`; do
useradd $i;
done

[ram2@atrcxb2957 t]$ cat tt  // set password for 50 users
#!/bin/bash

for i in `cat ./a` ; do
echo "ram" | passwd --stdin $i; done
====================================
// script to perform passwordless ssh from 1 linux server to another
#!/bin/bash
username=<username>
server=<Server_IP/Server_Hostname>

ssh-keygen -t rsa 
if [ $? -ne 0 ]; then 
echo "Could not generate the Key"
exit
fi

ssh-copy-id  -i ~/.ssh/id_rsa.pub  $username@$server
if [ $? -ne 0 ]; then 
echo "Could not copy public id from client to server"
exit
fi
echo "Passwordless SSH configured successfully"


=====================================

create a file with some content with the help of cat command.
cat > hello
enter the content followd by CTRL + D

[root@system1 ~]# date -u
Sat Mar 23 17:39:05 UTC 2019
[root@system1 ~]# date -s "Sat Mar 23 23:08:08"
Sat Mar 23 23:08:08 IST 2019
[root@system1 ~]#  date +"%T"
23:10:46
[root@system1 ~]# date +%B
March
[root@system1 ~]# date +%d
23
[root@system1 ~]# date +%D
03/23/19
[root@system1 ~]# date +%b
Mar
[root@system1 ~]# date +%y
19
[root@system1 ~]# date +%Y
2019
[root@system1 ~]# date +%F
2019-03-23
[root@system1 ~]# date +%f
%f


1> redirects stdout to filename 
1>> appends stdout to filename
2> redirects stderr to filename
&> redirects both stderr and stdout to a filename


ls ? will show all the files with single character as name
ls ??? will show all the files with three characters as name

[root@system1 ~]# ls a[a-d]c
aac  abc  acc  adc

[root@system1 ~]# ls *[0-9]* // it will display all the files whose name contains at least 1 digit

ls test_[!9]*  // it will print all the files except test_9
if want to create a file with special character in their name then can use "\"

touch \\
touch \$
touch hello\ there
[root@system1 test]# ls
$  \  hello there
touch hello\\\ there
[root@system1 test]# ls
hello\ there


===============================

find command:
for ignoring the case 
find . -iname abc.txt

find all files in current working directory whose name is not abc.txt
find . -not -iname abc.txt

find all files with .cpp or .sh extension

find . -name "*.cpp"  -o -name "*.sh"

find file with extension as .sh and its name contain "track" word
find . -name "*.sh" -a -name "*track*"

find all the files whose name contain "abc" but extension is not .php
find . -name "*abc*" ! -name "*.php"

how to find a file in 2 paths
find / /eniq -type f -name abc.txt

how to find hidden files
find . -name ".*" -type f

find a file whose permision is not 777

find . -type f ! -perm 777

find files for which stiky bit is set
find / -type f -perm /u=s

find all files in which read permission is set to user
find . -type f -perm /u=r

find all  the files owned by john
find /home -user john -type f

find all files modified in last 10 days
find . -type f -mtime 10

find all files accessed in last 10 days
find . -type f -atime 10

find all files which are modified in last 10 to 100 days (files which are modified in last 9 days should be excluded)
find . -type f -mtime +10 -mtime -100

for minutes we use word mmin amin cmin
find all files whose size is 50MB
find . -type f -size 50M

find files size between 50 to 100 MB
find . -type f -size +50M -size -100M

find empty files
find . -type f -empty
find . -type f -size 0

find file with name abc.txt and delete that files
find . -type f -name "abc.txt" -exec rm -rf {} \;

find . -type f -name "abc.txt"  | xargs ls -l {} \;

while finding if you want to search the file only upto 2 directories 
find . -maxdepth 2 -name abc.txt


Grep :
variants of grep 
egrep : extended grep for regular expression
fgrep : fixed strings
rgrep : reversed grep

find vijay word in all files recursively
grep -r "vijay" *

show all the data in file except vijay in file
grep -riv "vijay" *
r: recursively
i: ignore case
v: excluded

count the "vijay" word in file
grep -c "vijay" filename.txt

find "vijay" and "rahul" in file.txt
find -E -w "vijay|rahul" file.txt

find exact word "vijay" in file (not vijaya or avijay)
find -iw "vijay" file.txt

find just file name which contain "vijay" word
grep -l "vijay" * | sort |  uniq

find vijay , ajay word in file
grep [via]jay file.txt 
it will search for every combination of "via" followd by "jay" i. e. vjay, ijay, ajay, viajay , vijay , iajay

find 4 digit pattern in file
grep "[0-9][0-9][0-9][0-9]" file.txt

show 3 more lines after "vijay"
grep -A 3 "vijay" file.txt

show 3 lines before "vijay"
grep -B 3 "vijay" file.txt 

grep -f user.txt /etc/passwd
it will iterate through user.txt and for every word it will search the /etc/passwd file and display the matched pattern
  
different ways of array declaration
1)
var[0]="Hello"
var[1]="vijay"
var[2]="dear"

2)
var=("The"  "rate" "is" 45 "kg")

3) 
var=([0]="hello" [1]="vijay" dear)

4)
echo "enter Ip addressed seperated by space"
read -a ip_list // with -a option we are accepting the input and saving in array

for i in ${ip_list[@]}
do
	echo $i
done


"here document" concept
we can give multiline comment in code with here document concept

echo "this will print"

<< COMMENT

echo "this will not print"
touch filename   // this will not execute
echp " again this will not execute"

COMMENT

echo "this will also print"
here we can use any word instead of COMMENT ,the end word should be at the begining of the line


perform copy operation with dd command
dd if=/tmp/test.sh  of=/var/tmp/new_test.sh bs=10240


cat /proc/cpuinfo is same lscpu


1) what is difference between softlink and hardlink

A symbolic or soft link is an actual link to the original file, whereas a hard link is a mirror copy of the original file. If you delete the original file, the soft link has no value, because it points to a non-existent file. But in the case of hard link, it is entirely opposite. Even if you delete the original file, the hard link will still has the data of the original file. Because hard link acts as a mirror copy of the original file.

In a nutshell, a soft link

can cross the file system,
allows you to link between directories,
has different inode number and file permissions than original file,
permissions will not be updated,
has only the path of the original file, not the contents.
A hard Link

can’t cross the file system boundaries (i.e. A hardlink can only work on the same filesystem),
can’t link directories,
has the same inode number and permissions of original file,
permissions will be updated if we change the permissions of source file,
has the actual contents of original file, so that you still can view the contents, even if the original file moved or removed.

==========================
FOR Loop

        #!/bin/bash
        for i in `seq 1 10`;
        do
                echo $i
        done    
        
While sample
         #!/bin/bash 
         COUNTER=0
         while [  $COUNTER -lt 10 ]; do
             echo The counter is $COUNTER
             let COUNTER=COUNTER+1 
         done
         

Until sample
         #!/bin/bash 
         COUNTER=20
         until [  $COUNTER -lt 10 ]; do
             echo COUNTER $COUNTER
             let COUNTER-=1
         done
	
==========================
[ -a FILE ]	True if FILE exists.
[ -b FILE ]	True if FILE exists and is a block-special file.
[ -c FILE ]	True if FILE exists and is a character-special file.
[ -d FILE ]	True if FILE exists and is a directory.
[ -e FILE ]	True if FILE exists.
[ -f FILE ]	True if FILE exists and is a regular file.
[ -g FILE ]	True if FILE exists and its SGID bit is set.
[ -h FILE ]	True if FILE exists and is a symbolic link.
[ -k FILE ]	True if FILE exists and its sticky bit is set.
[ -p FILE ]	True if FILE exists and is a named pipe (FIFO).
[ -r FILE ]	True if FILE exists and is readable.
[ -s FILE ]	True if FILE exists and has a size greater than zero.
[ -u FILE ]	True if FILE exists and its SUID (set user ID) bit is set.
[ -w FILE ]	True if FILE exists and is writable.
[ -x FILE ]	True if FILE exists and is executable.
[ -O FILE ]	True if FILE exists and is owned by the effective user ID.
[ -G FILE ]	True if FILE exists and is owned by the effective group ID.
[ -L FILE ]	True if FILE exists and is a symbolic link.
[ -z STRING ]	True of the length if "STRING" is zero.
[ -n STRING ] or [ STRING ]	True if the length of "STRING" is non-zero.
=================================

1	
$0: The filename of the current script.

2	
$n:These variables correspond to the arguments with which a script was invoked. Here n is a positive decimal number corresponding to the position of an argument (the first argument is $1, the second argument is $2, and so on).

3	
$#: The number of arguments supplied to a script.

4	
$*: All the arguments are double quoted. If a script receives two arguments, $* is equivalent to $1 $2.
test.sh vijay ajay
"vijay ajay"

5	
$@: All the arguments are individually double quoted. If a script receives two arguments, $@ is equivalent to $1 $2.
test.sh vijay ajay
"vijay" "ajay"


6	
$?: The exit status of the last command executed.

7	
$$: The process number of the current shell. For shell scripts, this is the process ID under which they are executing.

8	
$!: The process number of the last background command.

===========================

basic for loop 
for i in `ls /etc/rc.*`; do
  echo $i
done


C-like for loop
for ((i = 0 ; i < 100 ; i++)); do
  echo $i
done

Ranges
for i in {1..5}; do
    echo "Welcome $i"
done

With step size
for i in {5..50..5}; do
    echo "Welcome $i"
done

cat file.txt | while read line; do
  echo $line
done

while true; do
  ···
done


defining functions
myfunc() {
    echo "hello $1"
}
# Same as above (alternate syntax)
function myfunc() {
    echo "hello $1"
}
myfunc "John"

returning values
myfunc() {
    local myresult='some value'
    echo $myresult
}
result="$(myfunc)"

Fruits=('Apple' 'Banana' 'Orange') // define array

// define array
Fruits[0]="Apple"
Fruits[1]="Banana"
Fruits[2]="Orange"

lines=(`cat logfile`)   // create array by reading from file


echo ${Fruits[0]}          Apple # Element #0
echo ${Fruits[-1]}         Orange # Last element
echo ${Fruits[@]}          Apple Banana Orange # All elements, space-separated
echo ${#Fruits[@]}         3 # Number of elements
echo ${#Fruits}            5 # String length of the 1st element
echo ${#Fruits[3]}         6 # String length of the Nth element

for i in "${arrayName[@]}"; do
  echo $i
done


dictionary in bash
declare -A sounds  // sounds is declared as associative array (two types of array associative and indexed array)

sounds[dog]="bark"
sounds[cow]="moo"
sounds[bird]="tweet"
sounds[wolf]="howl"

echo ${sounds[dog]} # Dog's sound
echo ${sounds[@]}   # All values
echo ${!sounds[@]}  # All keys
echo ${#sounds[@]}  # Number of elements
unset sounds[dog]   # Delete dog



Mention some ways to perform arithmetic operations in bash?

var1=$( expr 120 - 100 )
# print the result
echo $var1
# Calculate the addition by using let command
let var2=200+300
# Print the rsult
echo $var2
# Calculate and print the value of division using ‘bc’ to get the result
# with fractional value
echo "scale=2; 44/7" | bc
# Calculate the value of multiplication using double brackets
var3=$(( 5*3 ))
# Print the result
echo $var3



What is IFS?
IFS is a special shell variable. The full form of IFS is Internal Field Separator,
it acts as delimiter to separate the word from the line of text. It is mainly used for splitting a string, reading a command, replacing text etc.

Example:

#!/bin/bash
# Declare ':' as delimiter for splitting the text
IFS=":"
# Assign text data with ':' to $text
text="Red:Green:Blue"
for val in $text; do
    echo $val
done


How to find out the length of a string data? 

# Count length using `expr` length option
echo `expr length "I like PHP"`
# Count length using `wc` command
echo "I like Bash" | wc -c
# Count length using `awk` command
echo "I like Python" | awk '{print length}'

https://www.slashroot.in/suid-and-sgid-linux-explained-examples  // sticky bit , SUID and SGID

===========================

print specific portion of logfile based on date 

Feb 23 13:55:01 messagerie postfix/smtpd[20964]: connect from localhost[127.0.0.1]
Feb 23 13:55:02 messagerie postfix/smtpd[20964]: lost connection after CONNECT from localhost[127.0.0.1]
Feb 23 13:55:03 messagerie postfix/smtpd[20964]: disconnect from localhost[127.0.0.1]
Feb 23 13:55:04 messagerie pop3d: Connection, ip=[::ffff:127.0.0.1]
Feb 23 13:56:01 messagerie postfix/smtpd[20964]: connect from localhost[127.0.0.1]
Feb 23 13:56:01 messagerie postfix/smtpd[20964]: lost connection after CONNECT from localhost[127.0.0.1]
Feb 23 13:56:01 messagerie postfix/smtpd[20964]: disconnect from localhost[127.0.0.1]
Feb 23 13:57:01 messagerie pop3d: Connection, ip=[::ffff:127.0.0.1]
Feb 23 13:57:01 messagerie postfix/smtpd[20964]: connect from localhost[127.0.0.1]
Feb 23 13:57:01 messagerie postfix/smtpd[20964]: lost connection after CONNECT from localhost[127.0.0.1]
Feb 23 13:58:01 messagerie postfix/smtpd[20964]: disconnect from localhost[127.0.0.1]
Feb 23 13:58:01 messagerie pop3d: Connection, ip=[::ffff:127.0.0.1]


print every line it finds between the string Feb 23 13:56 and the string Feb 23 13:58

O/P:
way 1) 

 sed -n '/Feb 23 13.56/, /Feb 23 13.58/p' test_new.txt
 
Feb 23 13:56:01 messagerie postfix/smtpd[20964]: connect from localhost[127.0.0.1]
Feb 23 13:56:01 messagerie postfix/smtpd[20964]: lost connection after CONNECT from localhost[127.0.0.1]
Feb 23 13:56:01 messagerie postfix/smtpd[20964]: disconnect from localhost[127.0.0.1]
Feb 23 13:57:01 messagerie pop3d: Connection, ip=[::ffff:127.0.0.1]
Feb 23 13:57:01 messagerie postfix/smtpd[20964]: connect from localhost[127.0.0.1]
Feb 23 13:57:01 messagerie postfix/smtpd[20964]: lost connection after CONNECT from localhost[127.0.0.1]
Feb 23 13:58:01 messagerie postfix/smtpd[20964]: disconnect from localhost[127.0.0.1]

way 2)
 
 grep "Feb 23 13:5[6-8]" test_new.txt
Feb 23 13:56:01 messagerie postfix/smtpd[20964]: connect from localhost[127.0.0.1]
Feb 23 13:56:01 messagerie postfix/smtpd[20964]: lost connection after CONNECT from localhost[127.0.0.1]
Feb 23 13:56:01 messagerie postfix/smtpd[20964]: disconnect from localhost[127.0.0.1]
Feb 23 13:57:01 messagerie pop3d: Connection, ip=[::ffff:127.0.0.1]
Feb 23 13:57:01 messagerie postfix/smtpd[20964]: connect from localhost[127.0.0.1]
Feb 23 13:57:01 messagerie postfix/smtpd[20964]: lost connection after CONNECT from localhost[127.0.0.1]
Feb 23 13:58:01 messagerie postfix/smtpd[20964]: disconnect from localhost[127.0.0.1]
Feb 23 13:58:01 messagerie pop3d: Connection, ip=[::ffff:127.0.0.1]

==========================
