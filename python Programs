1) check whether strings are anagrams or not

>>> def test(s1 , s2):
	if (sorted(s1) == sorted(s2)):
		print("same")
	else:
		print("not anagram")

		
>>> test("silent" , "listen")
same
>>> test("silent" , "listenn")
not anagram


>>> def test(s1  , s2):
	n1=len(s1)
	n2=len(s2)
	if n1!= n2:
		return 0
	s1=sorted(s1)
	s2=sorted(s2)
	for i in range(0 , n1):
		if s1[i] != s2[i]:
			return 0
	return 1

>>> test("hi" , "ih")
1
>>> test("hi" , "ihi")
0
>>> if test('hi' , 'ih'):
	print("strings are anagram")
else:
	print("strings are not anagram")

	
strings are anagram
 without using any library with O(n) time complexity solve anargam strings problem :
def test(s1,s2):
    l1=list(s1)
    l2=list(s2)
    char_count= {}
    for char in l1:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1

    for char in l2:
        if char not in char_count:
            print("strings are not anagram")
            break
        char_count[char] -= 1
    else:
        for value in char_count.values():
            if value != 0:
                print('strings are not anagram ')
                break
        else:
            print("strings are anagram")

test("silent",'listen')
OP : 
strings are anagram
====================
Given two strings in lowercase, the task is to make them Anagram. 
The only allowed operation is to remove a character from any string.
Find minimum number of characters to be deleted to make both the strings anagram?
If two strings contains same data set in any order then strings are called Anagrams. 

Input : str1 = "bcadeh" str2 = "hea"
Output: 3
We need to remove b, c and d from str1.

Input : str1 = "cddgk" str2 = "gcd"
Output: 2

Input : str1 = "bca" str2 = "acb"
Output: 0

from collections import Counter

def removeChars(str1, str2):
    d1=dict(Counter(str1))
    d2=dict(Counter(str2))

    k1=d1.keys()
    k2=d2.keys()

    count1= len(k1)
    count2= len(k2)

    common = len(set(k1).intersection(set(k2)))

    if common == 0:
        print("op is ",count1+count2)
    else:
        print("op is",max(count1,count2)-common)

removeChars('abcdef','abc')
OP :
op is 3

========
Program to find first repetitive character in string/list

def test(l):
	s=set()
	for ch in l:
		if ch not in s:
			s.add(ch)
		else:
			return ch
			
>>> test([1,2,3,4,1])
1
>>> test("vijayv")
'v'

=====================
Find repeated character present first in a string
Input  : geeksforgeeks
Output : g
(mind that it will be g, not e.)

>>> def test(s):
	for i in range(len(s)):
		if s[i] in str(s[i+1:len(s)]):
			return s[i]

		
>>> test("geekforgeek")
'g'

============================
Find the character in first string that is present at minimum index in second string


Input: str = “geeksforgeeks”, patt = “set”
Output: e
Both e and s of patt are present in str,
but e is present at minimum index, which is 1.


def test(strr , ptn):
	mindex=100**3
	for i in range(len(ptn)):
		for j in range(len(strr)):
			if ptn[i] == strr[j] and j < mindex:
				mindex=j
				break
	if mindex != 100**3:
		print("minimum index is at {} position and character is {}".format(mindex, strr[mindex]))
	else:
		print("no character present")

		
>>> test("gelsforgeeks" , "set")
minimum index is at 1 position and character is e


Time Complexity: O(len(str)*len(ptn))
=============================
Find last index of a character in a string

Input : str = "geeks", x = 'e'
Output : 2
Last index of 'e' in "geeks" is: 2 

Input : str = "Hello world!", x = 'o'
Output : 7
Last index of 'o' is: 7 

>>> def test(strr , x):
	index=-1
	for i in range(len(strr)):
		if strr[i] == x:
			index=i
	if index != -1:
		print("last index is",index)
	else:
		print(" {} not found in {}".format(x, strr))

		
>>> test("hellohi", 'h')
last index is 5


Time Complexity : Θ(n)
========================
Find one extra character in a string

Input : string strA = "abcd";
        string strB = "cbdae";
Output : e
string B contain all the element 
there is a one extra character which is e

Input : string strA = "kxml";
        string strB = "klxml";
Output : l
string B contain all the element 
there is a one extra character which is l


>>> def findExtraCharacter(strA, strB): 

    m1 = {} 

    for i in strB: 
        if i in m1: 
            m1[i] += 1
        else: 
            m1[i] = 1

    for i in strA: 
        m1[i] -= 1
  
    for h1 in m1: 

        if m1[h1] == 1: 
            return h1

        
>>> findExtraCharacter("abc" , "abcde")
'd'

Time Complexity:- O(n)

=====================
Pallindrome string
>>> def test(s):
	i=0
	while i < (len(s)/2):
		if s[i] != s[len(s) -1 -i]:
			return False
		i+=1
	return True

>>> test("madam")
True

O(n)

===============

Python program to check if given string is vowel Palindrome
Given a string (may contain both vowel and consonant letters), remove all consonants, then check if the resulting string is palindrome or not.

Examples:

Input :  abcuhuvmnba
Output : YES
Explanation :
The consonants in the string "abcuhuvmnba"
are removed. Now the string becomes "auua".


>>> def test(s):
	v=("aeiou")
	ss=str()
	for i in range(len(s)):
		if s[i] in v:
			ss+=s[i]
	i=0
	while i < (len(ss)/2):
		if ss[i] != ss[len(ss) -i -1]:
			return False
		i+=1
	return True

>>> test("abcuhuvmnba")
True
>>> test("xayzuezyax")
False

========================
Program to accept string starting with vowel

def test(s):
	t=("aeiouAEIOU")
	if s[0] in t:
		print("valid string")
	else:
		print("invalid string")

		
>>> test("asfsd")
valid string
>>> test("Easknf")
valid string
>>> test("gdsfads")
invalid string

============
Python Regex – Program to accept string starting with vowel

>>> def test(s):
	regex="^[aeiouAEIOU][A-Za-z0-9]*"
	if re.search(regex , s):
		print("valid string")
	else:
		print("invalid string")

		
>>> test("animal")
valid string
>>> test("Iadsf")
valid string
>>> test("Pafas")
invalid string

================
Python Regex | Program to accept string ending with alphanumeric character

Input: ankitrai326
Output: Accept

Input: ankirai@
Output: Discard

>>> def test(s):
	regex="[A-Za-z0-9]$"
	if re.search(regex, s):
		print("valid string")
	else:
		print("invalid string")

		
>>> test("vijay9")
valid string
>>> test("vijay&")
invalid string

	
==================
Python Program for Fibonacci numbers

>>> def fibo(n):
	if n<0:
		print("INcorrect input")
	elif n==1:
		return 0
	elif n==2:
		return 1
	else:
		return fibo(n-1)+fibo(n-2)

	
>>> fibo(3)
1
>>> fibo(5)
3
====================
>>> def fibo(n):
	n1, n2, count=0,1,0
	if n <= 0:
		print("please enter positive number")
		return
	elif n ==1:
		print(n1)
	else:
		while count < n:
			print(n1)
			sum=n1+n2
			n1=n2
			n2=sum
			count+=1

			
>>> 
>>> fibo(3)
0
1
1
================
program to check first character of string is lower charcter/upper character/ number / special character

>>> def test(s):
	c=s[0]
	if (c>='a' and c<='z'):
		print("lower")
	elif (c>="A" and c<="Z"):
		print("upper")
	elif (c >='0' and c<="9"):
		print("number")
	else:
		print("special character")

		
>>> test("vijay")
lower
>>> test("Tea")
upper
>>> test("3sf")
number
>>> test("$afd")
special character

==================
Write a program that accepts a sentence and calculate the number of letters and digits.
Suppose the following input is supplied to the program:
hello world! 123
Then, the output should be:
LETTERS 10
DIGITS 3

>>> def test(s):
	l,d=0,0
	for i in s:
		if (i>='a')and (i<='z'):
			l+=1
		elif (i>='Z')and (i<='Z'):
			l+=1
		elif (i>='0') and (i<='9'):
			d+=1
	print("No of digits are ",d,"\n no of letters are",l)

	
>>> test("hello234")
No of digits are  3 
 no of letters are 5
 
 
 >>> def test(s):
	l,d=0,0
	for i in s:
		if i.isdigit():
			d+=1
		elif i.isalpha():
			l+=1
		else:
			pass
	print("digit",d,"letter",l)

	
>>> test("asdg4334")
digit 4 letter 4

============
Write a program that computes the value of a+aa+aaa+aaaa with a given digit as the value of a.
Suppose the following input is supplied to the program:
9
Then, the output should be:
11106

>>> def test(n):
	n1=int("%s"%(n))
	n2=int("%s%s"%(n,n))
	n3=int("%s%s%s"%(n,n,n))
	n4=int("%s%s%s%s"%(n,n,n,n))
	print(n1+n2+n3+n4)

	
>>> test(9)
11106

============
Use a list comprehension to square each odd number in a list. The list is input by a sequence of comma-separated numbers.

>>> def test():
	s=input("enter a comma seperated number")
	x=[int(i)*int(i) for i in s.split(",") if (int(i)%2)!=0]
	print(x)

	
>>> test()
enter a comma seperated number1,2,3,4,5
[1, 9, 25]

===========
take input of dictionary from user

>>> def test():
	n=int(input("enter total no of elements in dictionary"))
	i=0
	dict={}
	while i<n:
		inpt=input("enter key and value seperated by comma")
		key,value=inpt.split(",")
		dict[key]=value
		i+=1
	print(dict)

	
>>> test()
enter total no of elements in dictionary2
enter key and value seperated by comma1,2
enter key and value seperated by comma3,4
{'1': '2', '3': '4'}

>>> def test():
	dict={}
	n=int(input("enter size of dict"))
	for i in range(n):
		key=input("enter key")
		value=input("enter value")
		dict[key]=value
	print(dict)
	
	===================
Write a program that computes the net amount of a bank account based a transaction log from console input. The transaction log format is shown as following:
D 100
W 200

D means deposit while W means withdrawal.
Suppose the following input is supplied to the program:
D 300
D 300
W 200
D 100
Then, the output should be:
500

>>> def test():
	n=int(input("enter no of txn"))
	d=dict()
	for i in range(n):
		t=input("enter type")
		v=int(input("enter amount"))
		if t not in d.keys():
			d[t]=v
		else:
			d[t]+=v
	summ=0
	for k,v in d.items():
		if k == 'd':
			summ+=v
		else:
			summ-=v
	print(summ)
	
>>> test()
enter no of transcations2
enter transcation typeD
enter amount1000
enter transcation typeW
enter amount200

===========
A website requires the users to input username and password to register. Write a program to check the validity of password input by users.
Following are the criteria for checking the password:
1. At least 1 letter between [a-z]
2. At least 1 number between [0-9]
1. At least 1 letter between [A-Z]
3. At least 1 character from [$#@]
4. Minimum length of transaction password: 6
5. Maximum length of transaction password: 12
Your program should accept a sequence of comma separated passwords and will check them according to the above criteria. Passwords that match the criteria are to be printed, each separated by a comma.
Example
If the following passwords are given as input to the program:
ABd1234@1,a F1#,2w3E*,2We3345
Then, the output of the program should be:
ABd1234@1


>>> def test():
	import re
	values=[]
	items=[x for x in input().split(",")]
	for p in items:
		if len(p)<6 or len(p) > 12:
			continue
		elif not re.search("[A-Z]" ,p):
			continue
		elif not re.search("[a-z]" , p):
			continue
		elif not re.search("[$#@]",p):
			continue
		else:
			values.append(p)
	print(",".join(values))

	
>>> test()
ABd1234@1,a F1#,2w3E*,2We3345
ABd1234@1
>>> test()
abC23!#d
abC23!#d

========================
A robot moves in a plane starting from the original point (0,0). The robot can move toward UP, DOWN, LEFT and RIGHT with a given steps. The trace of robot movement is shown as the following:
UP 5
DOWN 3
LEFT 3
RIGHT 2
¡­
The numbers after the direction are steps. Please write a program to compute the distance from current position after a sequence of movement and original point. If the distance is a float, then just print the nearest integer.
Example:
If the following tuples are given as input to the program:
UP 5
DOWN 3
LEFT 3
RIGHT 2
Then, the output of the program should be:
2


def test():
	dic={}
	pos=[0,0]
	import math
	n=int(input("enter the total no of moves: "))
	for i in range(n):
		key=input("enter the direction: ")
		value=int(input("enter the unit: "))
		dic[key]=value
	for k,v in dic.items():
		if k == "UP":
			pos[1]+=v
		elif k =="DOWN":
			pos[1]-=v
		elif k =="RIGHT":
			pos[0]+=v
		elif k =="LEFT":
			pos[0]-=v
		else:
			pass
	dis=int(round(math.sqrt(pos[1]**2+pos[0]**2)))
	print(dis)

	
>>> test()
enter the total no of moves: 4
enter the direction: UP
enter the unit: 5
enter the direction: DOWN
enter the unit: 3
enter the direction: LEFT
enter the unit: 3
enter the direction: RIGHT
enter the unit: 2
2

=========================
Write a program to compute the frequency of the words from the input. The output should output after sorting the key alphanumerically. 
Suppose the following input is supplied to the program:
New to Python or choosing between Python 2 and Python 3? Read Python 2 or Python 3.
Then, the output should be:
2:2
3.:1
3?:1
New:1
Python:5
Read:1
and:1
between:1
choosing:1
or:2
to:1

def test():
	d={}
	s=input("enter the sentense: ").split()
	for i in s:
		if i in d:
			d[i] +=1
		else:
			d[i] = 1
	for i in sorted(d.keys()):
		print(i," : ",d[i])

		
>>> test()
enter the sentense: New to Python or choosing between Python 2 and Python 3? Read Python 2 or Python 3
2  :  2
3  :  1
3?  :  1
New  :  1
Python  :  5
Read  :  1
and  :  1
between  :  1
choosing  :  1
or  :  2
to  :  1

==================
Reverse words in a given String in Python

def test(s):
	l=s.split()
	l=l[::-1]
	print(" ".join(l))

	
>>> test("hello vijay how")
how vijay hello

==================
remove i’th character from string in Python

def test(s,i):
	return s[:i]+s[i+1:]

>>> test("vijay",1)
'vjay'
=============
1) Program to check if a string contains any special character

def test(s):
	import re
	regex = re.compile('[@_!#$%^&*()<>?/\|}{~:]')
	if(regex.search(s) == None):
		print("pass")
	else:
		print("fail")

		
>>> test('afa')
pass
>>> test('@afaf')
fail

2) Check if a given string is binary string or not

def test(s):
	ss=set(s)
	new={'0','1'}
	if ss == new or ss == {'0'} or ss == {'1'}:
		print("yes")
	else:
		print("no")
		
def test(s):
	return False if len(set(s)) > 2 else True
		
test("101010001")
yes

test("101012")
no


3) Find all close matches of input string from a list

from difflib import get_close_matches
def test(s , l):
	print(get_close_matches(s , l))

	
 test("ape" , ["apple", "appe" , "aep" , "apl"])
['appe', 'apple', 'apl']		

4) program to find uncommon words from two Strings

def test(s1 , s2):
	s=set()
	l1=s1.split()
	l2=s2.split()
	for i in l1:
		if i not in l2:
			s.add(i)
	for i in l2:
		if i not in l1:
			s.add(i)
	print(s)

	
>>> test("Geeks for Geeks" , "Learning from Geeks for Geeks")
set(['from', 'Learning'])


5) Permutation of a given string using inbuilt function

from itertools import permutations 
  
def test(str): 
       
     permList = permutations(str) 
     for perm in list(permList): 
         print (''.join(perm)) 
	 
test("ABC")
o/p :
ABC
ACB
BAC
BCA
CAB
CBA

6) Find all duplicate characters in string
from collections import Counter

def test(s):
	d=Counter(s)
	p=[]
	for k,v in d.items():
		if v > 1:
			p.append(k)
	print(p)

test("hihellohowareyou")
['e', 'h', 'l', 'o']


7) String slicing in Python to check if a string can become empty by recursive deletion

def check(input , ptn):
	if len(input) <= 0:
		return False
	while len(input) != 0:
		index=input.find(ptn)
		if index == (-1):
			return False
		input=input[:index] + input[index+len(ptn):]
	return True

	
	 check('GEEGEEKSKS' , 'GEEKS')
True
>>> check('GEEGEEKSKS' , 'GEES')
False

8) String slicing in Python to rotate a string
def rotate(s, no):
	org=s
	s=s[no:]+s[:no]
	print("left rotate with {} rotaton is {}".format(no , s))
	s=org
	s=s[-no:]+s[:-no]
	print("right rotation with {} rotation is {}".format(no , s))

	
>>> rotate("GeeksforGeeks" , 2)
left rotate with 2 rotaton is eksforGeeksGe
right rotation with 2 rotation is ksGeeksforGee

>>> rotate("qwertyu" , 2)
left rotate with 2 rotaton is ertyuqw
right rotation with 2 rotation is yuqwert


9) Execute a String of Code in Python
def test():
	loc="""print(5)"""
	exec(loc)

	
>>> test()
5

code = """ def factorial(num):
               for i in range(1,num+1):
                   fact = fact*i
               return fact
           print(factorial(5))"""
Output:
120

10) program to create a list of tuples from given list having number and its cube in each tuple
Input: list = [1, 2, 3]
Output: [(1, 1), (2, 8), (3, 27)]

l=[1,2,3]
>>> s=[(i, pow(i,3)) for i in l]
>>> s
[(1, 1), (2, 8), (3, 27)]

11)  program to convert time from 12 hour to 24 hour format
Input : 11:21:30 PM
Output : 23:21:30

Input : 12:12:20 AM
Output : 00:12:20

def convert24(str1): 
      
    # Checking if last two elements of time 
    # is AM and first two elements are 12 
    if str1[-2:] == "AM" and str1[:2] == "12": 
        return "00" + str1[2:-2] 
          
    # remove the AM     
    elif str1[-2:] == "AM": 
        return str1[:-2] 
      
    # Checking if last two elements of time 
    # is PM and first two elements are 12    
    elif str1[-2:] == "PM" and str1[:2] == "12": 
        return str1[:-2] 
          
    else: 
          
        # add 12 to hours and remove PM 
        return str(int(str1[:2]) + 12) + str1[2:8] 
  
# Driver Code         
print(convert24("08:05:45 PM")) 

12) print the content of file in reverese order:

for line in reversed(list(open(r"C:\Users\VIJAY\Desktop\file.txt"))):
	print(line)
	
	
13)Given an integer array, output all the unique pairs that sum up to a specific value k.

So the input:

pair_sum([1,3,2,2],4)

would return 2 pairs:

 (1,3)
 (2,2)

 def test(arr, k):
	if len(arr) < 2:
		print("lenght of {} is less than 2".format(arr))
		return
	output=set()
	seen=set()
	for i in arr:
		target=k-i
		if target not in seen:
			seen.add(i)
		else:
			output.add((min(i,target), max(target,i)))
	print(output)
	print(len(output))

	
>>> test([1,3,2,2],4)
{(1, 3), (2, 2)}
2

>>> def test(arr,k):
	op=set()
	for i in range(len(arr)):
		tgt=k-arr[i]
		if tgt in arr[i+1:len(arr)]:
			op.add((arr[i],tgt))
	print(op)
	print(len(op))

	
>>> test([1,3,2,2],4)
{(1, 3), (2, 2)}
2

14) Consider an array of non-negative integers. A second array is formed by shuffling the elements of the first array and deleting a random element. Given these two arrays, find which element is missing in the second array.

Here is an example input, the first array is shuffled and the number 5 is removed to construct the second array.

Input:

finder([1,2,3,4,5,6,7],[3,7,2,1,4,6])

Output:

5 is the missing number


def test(a1,a2):
	sum=0
	for i in a1:
		sum+=i
	for j in a2:
		sum-=j
	return sum

>>> test([1,2,3,4,5,6,7],[3,7,2,1,4,6])
5


def test(a1 , a2):
	d={}
	for i in a1:
		d[i]=1
	for i in a2:
		if i in d:
			d.pop(i)
	for k,v in d.items():
		print(" {} is missing ".format(k))

		
>>> test([1,2,3,4],[1,2,3])
 4 is missing 
 
def test(l1,l2):
	return sum(l1)-sum(l2)


 
15) 
Given a string in the form 'AAAABBBBCCCCCDDEEEE' compress it to become 'A4B4C5D2E4'. For this problem, you can falsely "compress" strings of single or double letters. For instance, it is okay for 'AAB' to return 'A2B1' even though this technically takes more space.

The function should also be case sensitive, so that a string 'AAAaaa' returns 'A3a3'.


 def test(s):
	s+=" "
	l=""
	count=0
	ss=""
	for i in range(len(s)):
		if s[i] != l:
			if i != 0:
				ss += l
				ss += str(count)
			l=s[i]
			count=1
		elif s[i] == l:
			count +=1
	print(ss)

	
>>> test("AAABB")
A3B2
>>> test("AAaaa")
A2a3


16) Given a string,determine if it is compreised of all unique characters. For example, the string 'abcde' has all unique characters and should return True. The string 'aabcde' contains duplicate characters and should return false.

 def test(s):
	for i in range(len(s)):
		if s[i] in str(s[:i]+s[i+1:]):
			return False
	return True

>>> test("abcd")
True
>>> test("abcdea")
False


def uni_char(s):
    return len(set(s)) == len(s)


def uni_char2(s):
    chars = set()
    for let in s:
        # Check if in set
        if let in chars:
            return False
        else:
            #Add it to the set
            chars.add(let)
    return True
	
	

17) Given a string of opening and closing parentheses, check whether it’s balanced. We have 3 types of parentheses: round brackets: (), square brackets: [], and curly brackets: {}. Assume that the string doesn’t contain any other character than these, no spaces words or numbers. As a reminder, balanced parentheses require every opening parenthesis to be closed in the reverse order opened. For example ‘([])’ is balanced but ‘([)]’ is not.

You can assume the input string has no spaces.


def test(s):
	if len(s)%2 != 0:
		return False
	opening=set('[({')
	matches=set([('(',')')  , ('{','}') , ('[',']')])
	stack=[]
	for i in s:
		if i in opening:
			stack.append(i)
		else:
			if len(stack) == 0:
				return False
			l_open=stack.pop()
			if (l_open , i) not in matches:
				return False
	return True

>>> test("({[]})")
True
>>> test("{{}}[([])]")
True
>>> test("{){})}")
False

18) Given the Stack class below, implement a Queue class using two stacks! Note, this is a "classic" interview problem. Use a Python list data structure as your Stack.

 class stacks2():
	def __init__(self):
		self.stack_in = []
		self.stack_out =[]
	def enqueue(self , item):
		self.stack_in.append(item)
	def dequeue(self):
		if not self.stack_out:
			while self.stack_in:
				self.stack_out.append(self.stack_in.pop())
		return self.stack_out.pop()

	
>>> d=stacks2()
>>> d.enqueue(1)
>>> d.enqueue(2)
>>> d.dequeue()
1
>>> d.dequeue()
2
>>> d.dequeue()
=================

print frequency of every character in string 
s="hellovijayhow"
1) 
import collections

print(collections.Counter(s))
Counter({'h': 2, 'l': 2, 'o': 2, 'e': 1, 'v': 1, 'i': 1, 'j': 1, 'a': 1, 'y': 1, 'w': 1})
2) 
>>> d={ i : s.count(i) for i in set(s)}
>>> d
{'o': 2, 'y': 1, 'v': 1, 'i': 1, 'e': 1, 'h': 2, 'w': 1, 'l': 2, 'j': 1, 'a': 1}
	
3) 
all_freq = {} 
  
for i in test_str: 
    if i in all_freq: 
        all_freq[i] += 1
    else: 
        all_freq[i] = 1
==========================

write a method to check no is even or odd without using modulus operator
method 1)
def even(n):
	return(n&1)
	
if even(20) == 0:
	print("even")
else:
	print("odd")

method 2)
def test(n):
	return (int(n/2)*2 ==n)
if test(4) == True:
	print("even")
else:
	print("odd")
	
==============
Fibonacci series 

1) recursively 
def fib_rec(n):
    
    # Base Case
    if n == 0 or n == 1:
        return n
    
    # Recursion
    else:
        return fib_rec(n-1) + fib_rec(n-2)
		
2) Dynamically 
n = 10
cache = [None] * (n + 1)


def fib_dyn(n):
    
    # Base Case
    if n == 0 or n == 1:
        return n
    
    # Check cache
    if cache[n] != None:
        return cache[n]
    
    # Keep setting cache
    cache[n] = fib_dyn(n-1) + fib_dyn(n-2)
    
    return cache[n]

3) iteratively 
def fib_iter(n):
    
    # Set starting point
    a = 0
    b = 1
    
    # Follow algorithm
    for i in range(n):
        
        a, b = b, a + b
        
    return a
=============================

reverse a string with recursion :
def reverse(s):
    
    # Base Case
    if len(s) <= 1:
        return s

    # Recursion
    return reverse(s[1:]) + s[0]
===================
	
4) date operations in python 
def test():
	y=int(input("enter the year"))
	m=int(input("enter the month"))
	d=int(input("enter the date"))
	date=datetime.date(y,m,d)
	print(date)
	
enter the year2019
enter the month12
enter the date12
2019-12-12


 def date_split():
	date_entry=input("enter date in yyyy-mm-dd format")
	year,month,date=map(int, date_entry.split("-"))
	date=datetime.date(year, month, date)
	print(date)

	
>>> date_split()
enter date in yyyy-mm-dd format2019-12-14
2019-12-14
===============

check whether date provvided by user is valid date or not ?
def test_date():
	inputdate=input("enter the date in dd/mm/yyyy format")
	day,month,year=inputdate.split("/")
	isValid=True
	try:
		datetime.datetime(int(year) , int(month), int(day))
	except ValueError:
		isValid=False
	if isValid:
		print("input date is valid ..")
	else:
		print("inout date is not valid ..")

		
>>> test_date()
enter the date in dd/mm/yyyy format30/3/19
input date is valid ..
>>> test_date()
enter the date in dd/mm/yyyy format30/3/20
input date is valid ..
>>> test_date()
enter the date in dd/mm/yyyy format30/2/19
inout date is not valid ..

we can compare two date with < , > operator

import datetime
from datetime import date as dt

 def test():
	year=int(input("enter year"))
	month=int(input("enter month"))
	date=int(input("enter date"))
	d1=datetime.date(year,month,date)
	d2=dt.today()
	if d1 > d2:
		print("{} is latest".format(d1))
	elif d1 < d2:
		print(" {} is latest".format(d2))
	else:
		print("both of the dates are same")

		
>>> test()
enter year2019
enter month12
enter date14
both of the dates are same
>>> test()
enter year2019
enter month12
enter date15
2019-12-15 is latest
>>> test()
enter year2019
enter month12
enter date12
 2019-12-14 is latest
 
 
=============== 
factorial one liner:
def fact(n):
	print(functools.reduce(lambda a,b:a*b , list(range(1,n+1))))
	
fact(3)
6

def fact(n): return 1 if n ==1 else n*fact(n-1)
fact(4)
24
======================

average of list elements in one line:
def test(l):
	return functools.reduce(lambda a,b : a+b,l)/len(l)
	
def test():
	l=[int(i) for i in input().split(",")]
	return sum(l)/len(l)

>>> test()
1,2,3,4,5
3.0


from statistics import mean
>>> def test(l):
	return mean(l)

>>> test([1,2,3,4,5])
3
================
Find no of digits in number

def test(n):
	if n == 0:
		return 1
	elif n <0:
		n = n* -1
	t=0
	while n > 0:
		n = int(n/10)
		t += 1
	return t

>>> test(0)
1
>>> test(23)
2
>>> test(-1213)
4
=================
check whether string are pangram or not ?

def test(s):
	if len(set('abcdefghijklmnopqrstuvwxyz')-set(s.lower()))== 0:
		return True
	else:
		return False
		
>>> test("The five boxing wizards jump quickly")
True
>>> test("Pack my box with five dozen liquor jugs")
True
>>> test("Pack my box with five dozen liquor ju")
False
================

program to count no of characters in string:
def test(s):
	print("length of {} is {}".format(s.replace(" ","") , len(s.replace(" ",""))))

	
>>> test("this string has four tabs")
length of thisstringhasfourtabs is 21
>>> test("this string has four spaces")
length of thisstringhasfourspaces is 23

=======================
count total lower case characters in string 

>>> def test(s):
	count=0
	for i in s:
		if i >= 'a' and i <= 'z':
			count+=1
	print(count)

	
>>> test("hey vijay HOW are you")
14
>>> def test(s):
	count=0
	for i in s:
		if i.islower():
			count+=1
	print(count)

	
>>> test("hey vijay HOW are you")
14

==================
find largest odd and largest even no in list 
 def test(l):
	l_o=-1
	l_e=-1
	for i in l:
		if i%2 == 0 and i > l_e:
			l_e = i
		elif i%2 != 0 and i > l_o:
			l_o = i
	print("largest odd is {}".format(l_o))
	print("largest even is {} ".format(l_e))

	
>>> test([2,4,3,1,5,7,4,8,33,66,55,11,77,99])
largest odd is 99
largest even is 66 
=========================
reverse a string with recursion 
def test(s):
	if len(s) == 0:
		return ''
	else:
		return test(s[1:]) + s[0]

	
>>> test('vijay')
'yajiv'

======================
program to check whether linked list contains a cycle
def cycle(node):
	marker1 = node
	marker2 = node
	while marker2 != None and marker2.next != None:
		marker1 = marker1.next
		marker2 = marker2.next.next
		if marker1 == marker2:
			return True
	return False
	
========================
You've been given a list of historical stock prices for a single day for Amazon stock. The index of the list represents the timestamp, so the element at index of 0 is the initial price of the stock, the element at index 1 is the next recorded price of the stock for that day, etc. Your task is to write a function that will return the maximum profit possible from the purchase and sale of a single share of Amazon stock on that day. Keep in mind to try to make this as efficient as possible.

For example, if you were given the list of stock prices:

prices = [12,11,15,3,10]

Then your function would return the maximum possible profit, which would be 7 (buying at 3 and selling at 10)
	
 def test(l):
	profit = 0
	for i in range(len(l)-1):
		if l[i] < max(l[i+1:]):
			     diff = max(l[i+1:]) - l[i]
			     if profit < diff:
				     profit = diff
	print("profit is {}".format(profit))

			     
			     
	
test([12, 11, 15, 3 , 10])
profit : 4 , buy : 11 , sell : 15


test([10,12,14,12,13,11,8,7,6,13,23,45,11,10])
profit : 39 , buy : 6 , sell : 45


===========================

Given a list of integers, write a function that will return a list, in which for each index the element will be the product of all the integers except for the element at that index

For example, an input of [1,2,3,4] would return [24,12,8,6] by performing [2×3×4,1×3×4,1×2×4,1×2×3]

Requirements
You can not use division in your answer! Meaning you can't simply multiply all the numbers and then divide by eahc element for each index!

 def test(l):
	  op = list()
	  for i in range(len(l)):
		  if i ==0 :
			  op.append(reduce(lambda x,y : x*y , l[1:]))
		  elif i == len(l)-1:
			  op.append(reduce(lambda x,y : x*y , l[:-1]))
		  else:
			  op.append(reduce(lambda x,y : x*y , l[:i]+l[i+1:]))
	  print(op)

	  
>>> test([1,2,3,4])
	  
[24, 12, 8, 6]
>>> test([0,1,2,3,4])
	  
[24, 0, 0, 0, 0]
=========================
Find the squareroot of a given number rounded down to the nearest integer, without using the sqrt function. For example, squareroot of a number between [9, 15] should return 3, and [16, 24] should be 4.

def test(n):
	if n < 0:
		raise ValueError
	elif n ==1:
		return 1
	for k in range(2,1+int(n/2)):
		if k**2 == n:
			return k
		elif k**2 >n:
			return k-1

		
>>> test(14)
3
>>> test(15)
3
>>> test(16)
4

=====================

Given a list of account ID numbers (integers) which contains duplicates , find the one unique integer. (the list is guaranteed to only have one unique (non-duplicated) integer

Requirements
Do not use built-in Python functions or methods

 def test(id_list):
    
    # Initiate unique Id
    unique_id = 0
    
    # XOR fo revery id in id list
    for i in id_list:
        
        # XOR operation
        unique_id ^= i
    
    return unique_id
	
test([123,456,789,234,123,456,789])
234

================
Remove duplicate characters in a given string keeping only the first occurrences. For example, if the input is ‘tree traversal’ the output will be ‘tre avsl’.

def test(s):
	op = ""
	for i in range(len(s)):
		if s[i] not in op:
			op += s[i]
	print(op)

	
>>> test('tree traversal')
tre avsl
===============

Sample Input

1222311
Sample Output

(1, 1) (3, 2) (1, 3) (2, 1)
Explanation

First, the character  occurs only once. It is replaced by . Then the character  occurs three times, and it is replaced by  and so on.

def test():
    s=input()
    s+=" "
    l = list()
    for i in range(len(s)):
        if i ==0:
            char = s[i]
            occur = 1
        else:
            if char == s[i]:
                occur +=1
            else:
                l.append((occur, int(char)))
                char = s[i]
                occur = 1
    [ print(x, end=' ') for x in l]

    
>>> test()
1222311
(1, 1) (3, 2) (1, 3) (2, 1) 

================
Given an array of integers arr, a lucky integer is an integer which has a frequency in the array equal to its value.

Return a lucky integer in the array. If there are multiple lucky integers return the largest of them. If there is no lucky integer return -1.

 

Example 1:

Input: arr = [2,2,3,4]
Output: 2
Explanation: The only lucky number in the array is 2 because frequency[2] == 2.
Example 2:

Input: arr = [1,2,2,3,3,3]
Output: 3
Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them.



    def findLucky(self, arr: List[int]) -> int:
	    d = collections.Counter(arr)
	    ll = list()
	    for k,v in d.items():
		    if k == v:
			    ll.append(k)
	    ll.sort()
	    return -1 if len(ll) == 0 else ll.pop()
		

def test(s):
	f=[]
	for i in s:
		if i == s.count(i):
			f.append(i)
	return max(f) if f else -1
	
=================================
Balanced strings are those who have equal quantity of 'L' and 'R' characters.

Given a balanced string s split it in the maximum amount of balanced strings.

Return the maximum amount of splitted balanced strings.

 

Example 1:

Input: s = "RLRRLLRLRL"
Output: 4
Explanation: s can be split into "RL", "RRLL", "RL", "RL", each substring contains same number of 'L' and 'R'.
Example 2:

Input: s = "RLLLLRRRLR"
Output: 3
Explanation: s can be split into "RL", "LLLRRR", "LR", each substring contains same number of 'L' and 'R'.


    def balancedStringSplit(self, s: str) -> int:
        char_count = total = 0
        for i in s:
            char_count += 1 if i == 'L' else -1
            if char_count == 0:
                total +=1
        return total
		
		
=====================
 Decrypt String from Alphabet to Integer Mapping
Given a string s formed by digits ('0' - '9') and '#' . We want to map s to English lowercase characters as follows:

Characters ('a' to 'i') are represented by ('1' to '9') respectively.
Characters ('j' to 'z') are represented by ('10#' to '26#') respectively. 
Return the string formed after mapping.

It's guaranteed that a unique mapping will always exist.

 

Example 1:

Input: s = "10#11#12"
Output: "jkab"
Explanation: "j" -> "10#" , "k" -> "11#" , "a" -> "1" , "b" -> "2".
Example 2:

Input: s = "1326#"
Output: "acz"
Example 3:

Input: s = "25#"
Output: "y"

WAY 1)
 def freqAlphabets(self, s: str) -> str:
    	mp={'1':'a','2':'b','3':'c','4':'d','5':'e','6':'f','7':'g','8':'h','9':'i','10#':'j','11#':'k','12#':'l','13#':'m','14#':'n','15#':'o','16#':'p','17#':'q','18#':'r','19#':'s','20#':'t','21#':'u','22#':'v','23#':'w','24#':'x','25#':'y','26#':'z'}
        op=str()
	    start = 0
	    while start < len(s)-2:
		    if s[start+2] == '#':
			    op += mp.get(s[start]+s[start+1]+s[start+2])
			    start += 3
		    else:
			    op+=mp.get(s[start])
			    start += 1
	    if s[-1] != '#':
		    op+=mp.get(s[-2])
		    op+=mp.get(s[-1])
		
	    return op
WAY 2)
def test(s):
	mp={'1':'a','2':'b','3':'c','4':'d','5':'e','6':'f','7':'g','8':'h','9':'i','10#':'j','11#':'k','12#':'l','13#':'m','14#':'n','15#':'o','16#':'p','17#':'q','18#':'r','19#':'s','20#':'t','21#':'u','22#':'v','23#':'w','24#':'x','25#':'y','26#':'z'}
	s+="  "
	op=""
	i = 0
	while True:
		if s[i] == " ":
			break
		else:
			if s[i+2] == "#":
				op += mp[s[i] + s[i+1] + "#"]
				i+=3
			else:
				op += mp[s[i]]
				i+=1
	return op

===================

Count Negative Numbers in a Sorted Matrix

Given a m * n matrix grid which is sorted in non-increasing order both row-wise and column-wise. 

Return the number of negative numbers in grid.

 

Example 1:

Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
Output: 8
Explanation: There are 8 negatives number in the matrix.
Example 2:

Input: grid = [[3,2],[1,0]]
Output: 0

def test(grid):
	count = 0
	for row in grid : count += len([x for x in row if x <0])
	return count
	
	=========================
	
Unique Morse Code Words

International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on.

For convenience, the full table for the 26 letters of the English alphabet is given below:

[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cab" can be written as "-.-..--...", (which is the concatenation "-.-." + ".-" + "-..."). We'll call such a concatenation, the transformation of a word.

Return the number of different transformations among all words we have.

Example:
Input: words = ["gin", "zen", "gig", "msg"]
Output: 2
Explanation: 
The transformation of each word is:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

There are 2 different transformations, "--...-." and "--...--.".

def test(words):
	s=set()
	mapp={'a':".-",'b':"-...",'c':"-.-.",'d':"-..",'e':".",'f':"..-.",'g':"--.",'h':"....",'i':"..",'j':".---",'k':"-.-",'l':".-..",'m':"--",'n':"-.",'o':"---",'p':".--.",'q':"--.-",'r':".-.",'s':"...",'t':"-",'u':"..-",'v':"...-",'w':".--",'x':"-..-",'y':"-.--",'z':"--.."}
	temp=str()
	for char in words:
		temp=str()
		for ltr in char:
			temp+=mapp.get(ltr)
		s.add(temp)
	return len(s)
	

====================

 1 - Write a function that checks whether any **permutation** of an input string is a palindrome.
 Assume the input string contains only lowercase letters.

 Example:

 "radar" - True
 "aarrd" - True
 "apple" - False
 "eppla" - False
 from itertools import permutations


	def test(s):
     new_s = list(permutations(s))
     flag = False
     for i in list(new_s):
         if "".join(reversed(i)) == "".join(i):
             print("".join(i))
             flag = True
             break
     if flag:
         print("True")
     else:
         print("False")

 test("rad")

=======================
wap to fetch random line from file

 def test():
	with open(r'C:\Users\VIJAY\Desktop\test.txt', 'r') as f:
		data=f.readlines()
	n=len(data)
	line=random.randint(0,n-1)
	print(data[line])

	
>>> test()
5

>>> test()
1

==================
find permutation of string without using itertools

>>> def test(x):
	final = [[]]
	l=len(x)
	groups=[list(x)] *l
	op = []
	for i in groups:
		final = [x+[y] for x in final for y in i]
	for k in final:
		op.append("".join(k))
	return op

>>> list(product('abc'))
['aaa', 'aab', 'aac', 'aba', 'abb', 'abc', 'aca', 'acb', 'acc', 'baa', 'bab', 'bac', 'bba', 'bbb', 'bbc', 'bca', 'bcb', 'bcc', 'caa', 'cab', 'cac', 'cba', 'cbb', 'cbc', 'cca', 'ccb', 'ccc']
=================
wap to find length of longest substring without repeating characters

def test(s):
    maxlen=-1
    maxstr=""
    if len(s) == 0:
        return -1
    else:
        for i in range(len(s)):
            tmp = s[i]
            for j in range(i+1, len(s)):
                if s[j] not in tmp:
                    tmp += s[j]
                    if len(tmp) > maxlen:
                        maxlen= len(tmp)
                        maxstr= tmp
                else:
                    break
    if len(tmp) > maxlen:
        maxlen=len(tmp)
        maxstr=tmp
    print("max len is {} maxstr is {}".format(maxlen,maxstr))

#test('enjoyalgorithms')
#test('abcabcbb')
test('bbbb')
test('pwwkew')

====================

wap to count distinct elements present in every k sized window of array 
for ex : arrary [1,1,1,3,4,2,3] and k = 4
op : [2, 3, 4, 3]
explanation : in first 4 elements i. e. 1,1,1,3 there are 2 distinct elements hence first element in op list is 2

def test(l,k):
    op=list()
    for i in range(len(l)-k+1):
        op.append(len(set(l[i:i+4])))
    print(op)

test([1,2,4,4,2],3)

================
find permutation of string without using itertools

>>> def test(x):
	final = [[]]
	l=len(x)
	groups=[list(x)] *l
	op = []
	for i in groups:
		final = [x+[y] for x in final for y in i]
	for k in final:
		op.append("".join(k))
	return op

>>> list(product('abc'))
['aaa', 'aab', 'aac', 'aba', 'abb', 'abc', 'aca', 'acb', 'acc', 'baa', 'bab', 'bac', 'bba', 'bbb', 'bbc', 'bca', 'bcb', 'bcc', 'caa', 'cab', 'cac', 'cba', 'cbb', 'cbc', 'cca', 'ccb', 'ccc']
===========
>>> test()
1
========================
==============================

Given a matrix of n X n. The task is to calculate the absolute difference between the sums of its diagonal.

Input : mat[][] = 11 2 4
                   4 5 6
                  10 8 -12 
Output : 15
Sum of primary diagonal = 11 + 5 + (-12) = 4.
Sum of secondary diagonal = 4 + 5 + 10 = 19.
Difference = |19 - 4| = 15.


Input : mat[][] = 10 2
                   4 5
Output : 9


CODE : 
def test(m,n):
    d1=0
    d2=0
    for i in range(n):
        for j in range(n):
            if i == j:
                d1+=m[i][j]
            if i == n - j -1 :
                d2+=m[i][j]
    print("diff is ",abs(d1-d2))



matrix = [[11,2,4], [4,5,6], [10,8,-12]]
test(matrix, 3)

================
Move 0's to end of the list without creating a new list or any inbuilt function
a= [1, 2, 3, 0, 0, 0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0, 0,9, 8, 7,0,10,11]


def test(a):
    ind=0
    for i in range(len(a)):
        if a[i] !=0:
            a[ind] , a[i] = a[i], a[ind]
            ind +=1
    print(a)

a= [1, 2, 3, 0, 0, 0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0, 0,9, 8, 7,0,10,11]
test(a)
=========
how to sort the dictionary with its values 

footballers_goals = {'Eusebio': 120, 'Cruyff': 104, 'Pele': 150, 'Ronaldo': 132, 'Messi': 125}

temp = dict(sorted(footballers_goals.items() , key=lambda x : x[1])) # sorted by value

print(temp)
#{'Cruyff': 104, 'Eusebio': 120, 'Messi': 125, 'Ronaldo': 132, 'Pele': 150}


temp = dict(sorted(footballers_goals.items() , key=lambda x : x[0])) # sorted by key

print(temp)
#{'Cruyff': 104, 'Eusebio': 120, 'Messi': 125, 'Pele': 150, 'Ronaldo': 132}

===================
convert roman to integer no 

def convert(s):
    romans = {
        'I':1,
        "V":5,
        'X':10,
        "L":50,
        "C":100,
        'D':500,
        'M':1000,
        'IV':4,
        'IX':9,
        'XL':40,
        'XC':90,
        'CD':400,
        'CM':900
    }
    op=0
    i=0
    while i<len(s):
        if i+1 < len(s) and s[i]+s[i+1] in romans:
            op+= romans[s[i]+s[i+1]]
            i+=2
        else:
            op+=romans[s[i]]
            i+=1
    print(op)

convert('XLIV')

==============
Given an integar array nums return all triplets such that nums[i] + nums[j] + nums[k] = 0 and i!=j and j!=k and i!=k 
solution triplets should not contain duplicate items

def test(nums):
    s=set()
    h=dict()
    n=len(nums)
    for i,num in enumerate(nums):
        h[num] = i
    for i in range(n):
        for j in range(i+1,n):
            desired = -nums[i] - nums[j]
            if desired in h and h[desired] != i and h[desired] != j:
                s.add(tuple(sorted([desired, nums[i],nums[j]])))
    print(s)

test([-1,0,-1,2,1,-4])

OP : 
{(-1, 0, 1), (-1, -1, 2)}

==========
Given an array of strings strs, group the anagrams together. You can return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

 

Example 1:

Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]


from collections import defaultdict
def test(strs):
    anagram_dict = defaultdict(list)
    for s in strs:
        count=[0]*26
        for c in s:
            count[ord(c)-ord('a')] += 1
        key = tuple(count)
        anagram_dict[key].append(s)
        print(anagram_dict)
    return anagram_dict.values()

print(test(['eat','ate','tea']))

================

Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.

Input: board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: true


class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        for i in range(9):
            s=set()
            for j in range(9):
                if board[i][j] in s:
                    return False
                elif board[i][j] != '.':
                    s.add(board[i][j])

        for i in range(9):
            s=set()
            for j in range(9):
                if board[j][i] in s:
                    return False
                elif board[j][i] != '.':
                    s.add(board[j][i])

        start=[(0,0),(0,3),(0,6),
                (3,0),(3,3),(3,6),
                (6,0),(6,3),(6,6)]
        for i,j in start:
            s=set()
            for row in range(i,i+3):
                for col in range(j,j+3):
                    if board[row][col] in s:
                        return False
                    elif board[row][col] != '.':
                        s.add(board[row][col])
        return True


=================
Longest consecutive sequence 
Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.

You must write an algorithm that runs in O(n) time.

 

Example 1:

Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.


class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        s=set(nums)
        longest=0
        for num in nums:
            if num-1 not in nums :
                next_num = num +1
                length = 1
                while next_num in s:
                    length +=1
                    next_num +=1
                longest = max(longest, length)
        return longest
        
		
===================
A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string s, return true if it is a palindrome, or false otherwise.

 

Example 1:

Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.

class Solution:
    def isPalindrome(self, s: str) -> bool:
        l=0
        r=len(s)-1
        while l<r:
            if not s[l].isalnum():
                l+=1
                continue
            if not s[r].isalnum():
                r-=1
                continue
            if s[l].lower() != s[r].lower():
                return False
            
            l+=1
            r-=1
        return True
         
=====================
two sum input array is sorted 


Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.

Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.

The tests are generated such that there is exactly one solution. You may not use the same element twice.

Your solution must use only constant extra space.

 

Example 1:

Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].


class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l=0
        r=len(numbers)-1
        while l < r:
            if numbers[l]+numbers[r] > target:
                r-=1
            elif numbers[l]+numbers[r] < target:
                l+=1
            else:
                return [l+1,r+1]
        
		==========================
Container with most water

https://leetcode.com/problems/container-with-most-water/description/

You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return the maximum amount of water a container can store.

Notice that you may not slant the container.

 

Example 1:


Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.

		

class Solution:
    def maxArea(self, height: List[int]) -> int:
        l=0
        r=len(height)-1
        max_area = 0
        while l < r:
            w=r-l
            h=min(height[r],height[l])
            area = w*h
            max_area = max(max_area, area)
            if height[l] < height[r]:
                l+=1
            else:
                r-=1
        return max_area
        
		
==================
3 sum 

Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.

 

Example 1:

Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.


class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        h=dict()
        n=len(nums)
        s=set()
        for i,val in enumerate(nums):
            h[val]=i
        for i in range(n):
            for j in range(i+1, n):
                desired = - nums[i] - nums[j]
                if desired in h and h[desired] != i and h[desired] != j:
                    s.add(tuple(sorted([nums[i],nums[j],desired])))
        return s
        
=========================
Trapping rain water	
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.

https://www.youtube.com/watch?v=KFdHpOlz8hs&list=PLKYEe2WisBTFEr6laH5bR2J19j7sl5O8R&index=13


class Solution:
    def trap(self, height: List[int]) -> int:
        n=len(height)
        l_wall = r_wall = 0
        max_left = [0]*n
        max_right = [0]*n

        for i in range(n):
            j=-i-1
            max_left[i] = l_wall
            max_right[j]= r_wall
            l_wall = max(height[i], l_wall)
            r_wall = max(height[j], r_wall)
        
        summ = 0
        for i in range(n):
            pot = min(max_left[i], max_right[i])
            summ += max(0, pot - height[i])
        return summ
===================
Daily temperatures 
https://www.youtube.com/watch?v=_ZEvmycwXHs&list=PLKYEe2WisBTFEr6laH5bR2J19j7sl5O8R&index=15

Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.

 

Example 1:

Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]

class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n=len(temperatures)
        ans=[0]*n
        stk=list()
        for i,t in enumerate(temperatures):
            while stk and stk[-1][0] < t:
                stk_t , stk_i = stk.pop()
                ans[stk_i] = i-stk_i
            stk.append((t,i))
        return ans         
		
====================
Reverse polish notation 

https://www.youtube.com/watch?v=ffgmKxRqiMc&list=PLKYEe2WisBTFEr6laH5bR2J19j7sl5O8R&index=17


You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.

Evaluate the expression. Return an integer that represents the value of the expression.

Note that:

The valid operators are '+', '-', '*', and '/'.
Each operand may be an integer or another expression.
The division between two integers always truncates toward zero.
There will not be any division by zero.
The input represents a valid arithmetic expression in a reverse polish notation.
The answer and all the intermediate calculations can be represented in a 32-bit integer.
 

Example 1:

Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9

from math import ceil, floor
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stk=list()
        for  t in tokens:
            if t in '+-*/':
                b,a=stk.pop(), stk.pop()

                if t == '+':
                    stk.append(a+b)
                elif t == '-':
                    stk.append(a-b)
                elif t == '*':
                    stk.append(a*b)
                else:
                    division = a/b
                    if division <0:
                        stk.append(ceil(division))
                    else:
                        stk.append(floor(division))
            else:
                stk.append(int(t))
        return stk.pop(0)

        
======================
https://leetcode.com/problems/search-a-2d-matrix/description/
https://www.youtube.com/watch?v=x-dYOtIudzc&list=PLKYEe2WisBTFEr6laH5bR2J19j7sl5O8R&index=19

You are given an m x n integer matrix matrix with the following two properties:

Each row is sorted in non-decreasing order.
The first integer of each row is greater than the last integer of the previous row.
Given an integer target, return true if target is in matrix or false otherwise.

You must write a solution in O(log(m * n)) time complexity.

Example 1:

Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m=len(matrix)
        n=len(matrix[0])
        t=m*n
        l=0
        r=t-1
        while l <= r:
            m=(l+r)//2
            i=m//n
            j=m%n
            if target == matrix[i][j]:
                return True
            elif target < matrix[i][j]:
                r=m-1
            else:
                l=m+1
        return False
		
===================
Reverse a signed number without using str() function 

def test(n):
    temp = 0
    if n >0:
        while n>0:
            t=n%10
            temp = temp*10 + t
            print(temp)
            n=int(n/10)
        print('temp is ',temp)
    else:
        while n<0:
            t=(-1*n)%10
            temp = temp*10 + t
            print(temp)
            n=int(n/10)
        print('temp is ',temp*-1)
test(-789)

IP : 123
OP : 321
IP : -789
OP : -987

============
Tree Implementaion 

class binaryTreeNode():
    def __init__(self,data):
        self.data = data
        self.left=None
        self.right=None

def printTree(root):
    if root == None:
        return None
    print(root.data , end=": ")
    if root.left != None:
        print("L",root.left.data, end=" ")
    if root.right != None:
        print("R",root.right.data, end=" ")
    print()
    printTree(root.left)
    printTree(root.right)

#printTree(btn1)
def treeInput():
    rootData=int(input())
    if rootData == -1:
        return None
    root = binaryTreeNode(rootData)
    leftTree =  treeInput()
    rightTree = treeInput()
    root.left = leftTree
    root.right= rightTree
    return root

def count_nodes(root):
    if root == None:
        return 0
    leftCount=  count_nodes(root.left)
    rightCount = count_nodes(root.right)
    return leftCount + rightCount + 1


def preOrder(root):
    if root:
        print(root.data)
        preOrder(root.left)
        preOrder(root.right)

def postOrder(root):
    if root:
        postOrder(root.left)
        postOrder(root.right)
        print(root.data)


def inOrder(root):
    if root:
        inOrder(root.left)
        print(root.data)
        inOrder(root.right)

def countmax(root):
    if root == None:
        return -1
    maxleft = countmax(root.left)
    maxright = countmax(root.right)
    maximum = max(root.data, maxleft, maxright)
    return maximum

def height(root):
    if root == None:
        return 0
    leftheight = height(root.left)
    rightheight = height(root.right)
    return max(leftheight , rightheight) + 1


def leafNodes(root):
    if root == None:
        return 0
    if root.left == None and root.right == None:
        return 1
    leftleaf = leafNodes(root.left)
    rightleaf = leafNodes(root.right)
    return leftleaf + rightleaf


def isbalanced(root):
    if root is None:
        return True
    leftheight = height(root.left)
    rightheight= height(root.right)

    if leftheight - rightheight > 1 or rightheight - leftheight > 1:
        return False

    isLeftbalanced = isbalanced(root.left)
    isRightbalanced = isbalanced(root.right)

    if isLeftbalanced and isRightbalanced:
        return True
    else:
        return False


root  = treeInput()
print("Tree is balanced or not : ",isbalanced(root))

#print("leaf nodes are")
#print(leafNodes(root))
#print("max data is ")
#print(countmax(root))
#print("height of tree is ")
#print(height(root))
# print("total no of nodes",count_nodes(root))
# printTree(root)
# print("Preoder traversal is ")
# preOrder(root)
# print("inOrder traversal is ")
# inOrder(root)
# print("postOrder traversal is")
# postOrder(root)

==============
find minimum no of platforms required for the railway station below provided are arrival and departure timing of trains
    

def test(arr, dep):
    count=max=1
    arr.sort()
    dep.sort()
    i=1
    j=0
    n=len(arr)
    while i <n and j <n:
        if arr[i] <= dep[j]:
            i+=1
            count+=1
            if count > max:
                max=count
        else:
            j+=1
            count-=1
    return max

arr=[900,940,950,1100,1500,1800]
dep=[910,1200,1120,1130,1900,2000]
print(test(arr,dep))

===========================
===========
Given an array of elements , having some non zero and some zero elements.wirte a program to move all the zeros to end of the array by maintaining 
sequence of nonzero intact

def test(n):
    l=len(n)
    x=[0]*l
    j=0
    for i,p in enumerate(n):
        if p != 0:
            x[j] = p
            j+=1
    print(x)

test([0.1,1,1.1,0,2,0,3,4,0,0,5])

OP:
[0.1, 1, 1.1, 2, 3, 4, 5, 0, 0, 0, 0]
===========
