Following python Modules are used:
paramiko, paramiko_expect ,pytest, csv, json, shutil,  logging, itertools, functools, subprocess, os,time,  datetime, sys, math
=========================
difference between a+, r+ and w+ in file handling python
r+ Opens a file for both reading and writing. The file pointer placed at the beginning of the file for reading and for writing pointer is placed at end of file. 
w+ Opens a file for both writing and reading. Overwrites the existing file if the file exists.if file exists already then existing data is flushed out.
a+ Open for reading and appending (writing at end of file). The file is created if it does not exist. The initial file position for reading is at the beginning of the file, but output is appended to the end of the file. need to use method f.seek(0) in order to move the seek pointer to zeroth position in order to read data from first line

=================

Closure

https://www.programiz.com/python-programming/closure
==========================

#importing module 
import logging 

#Create and configure logger 
logging.basicConfig(filename=r"C:\Users\VIJAY\Desktop\test.txt", 
					format='%(asctime)s %(message)s', 
					filemode='w') 

#Creating an object 
logger=logging.getLogger()


#Setting the threshold of logger to DEBUG 
logger.setLevel(logging.DEBUG)

#Test messages 
logger.debug("Harmless debug Message") 
logger.info("Just an information") 
logger.warning("Its a Warning") 
logger.error("Did you try to divide by zero") 
logger.critical("Internet is down") 


https://www.geeksforgeeks.org/logging-in-python/


===================
paramiko is used for performing ssh over another server, executing commands over there and getting the output/ error of that commands


import paramiko

ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh.connect(hostname, username = 'vijay', password='Vijay123')
stdin, stdout, stderr = ssh.exec_command('df -hk')
print(stdout.readlines())

there are 2 paramiko policies
1) reject policy ( default policy)
2) autoadd policy

by default all the ssh.connect(hostname, username = 'vijay', password='Vijay123') will fail saying that known_hosts file doesn't contain the entry of hostname.
so we need to add the AutoAddPolicy to paramiko after that this error will not appear


https://www.youtube.com/watch?v=kvPa85M9z2Q

=====================

paramiko expect provides expect like functionality to paramiko ssh library.

from paramiko_expect import SSHClientInteraction


self.client = paramiko.SSHClient()
arglist = {1:'one', 2:'two', 3:'three'}
password_prompt = '.*password.*'
prompt = '.*$.*'
value = '.*.*'
interact = SSHClientInteraction(self.client, timeout=10, display=True)
interact.expect(prompt, default_match_prefix='.*')
interact.send("openssl enc -e -aes-256-cbc -md md5 -a <<<" + "'" + collector_password + "'")
interact.expect(password_prompt)
interact.send(arglist[3])
interact.expect(password_prompt)

============================
Implement selection sort 


>>> def selection(a):
	for i in range(len(a)):
		lowest=i
		for j in range(i+1 , len(a)):
			if a[j] < a[lowest]:
				lowest =j
		a[i] , a[lowest]=a[lowest] , a[i]

		
>>> selection(a)
>>> a
[1, 2, 3, 4]

worst case : O(n2)
average case: O(N2)
best case : O(n2)

============================
Implement bubble sort

>>> def bubble(a):
	s=True
	while s:
		s=False
		for i in range(len(a) -1):
			if a[i] > a[i+1]:
				a[i] , a[i+1] = a[i+1] , a[i]
				s=True

				
>>> a=[2,3,1,5,4]
>>> bubble(a)
>>> a
[1, 2, 3, 4, 5]

worst case : O(n2)
average case: O(N2)
best case : O(n)

=====================
Implement binary search iterative 

def test(l,key):
	lft=0
	rht=len(l)-1
	while lft <= rht:
		mid=int(lft + (rht-lft)/2)
		if l[mid] == key:
			return mid
		elif l[mid] < key:
			lft = mid+1
		else:
			rht = mid-1
	return -1
	
time complexity : O(log n)
=================
Implement Binray search with recursion

>>> def bs(a , l , r , x):
	if r >= l:
		mid= int(l+ ( r-l )/2)
		if a[mid] == x:
			return mid
		elif a[mid] > x:
			return bs(a , l , mid -1 , x)
		else:
			return bs(a , mid+1 , r, x)
	else:
		return -1
========================
Implement singly linked list 

class node:
	def __init(self , data):
		self.data=data
		self.next=None
		
		
class ll:
	def __init__(self):
		self.head=None
	def traverse(self):
		n=self.head
		if n is None:
			print("List is Empty")
			return
		else:
			while n is not None:
				print(n.data," ")
				n=n.next
	def insert_at_start(self , data):
		n=node(data)
		n.next=self.head
		self.head=n
	def insert_at_end(self,data):
		n=node(data)
		if self.head is None:
			self.head = n
			return
		else:
			tmp=self.head
			while tmp.next is not None:
				n=n.next
			tmp.next=n
==========================
Implement deque with python priovided package

import collections
>>> lst=collections.deque()
>>> lst.append("a")
>>> lst
deque(['a'])
>>> lst.append("b")
>>> lst
deque(['a', 'b'])
>>> lst.reverse()
>>> lst
deque(['b', 'a'])
>>> lst.reverse()
>>> lst
deque(['a', 'b'])
>>> lst.appendleft("c")
>>> lst
deque(['c', 'a', 'b'])
>>> lst.pop()
'b'
>>> lst.popleft()
'c'
>>> lst
deque(['a'])
>>> lst.append("b")
>>> lst
deque(['a', 'b'])
>>> lst.append("c")
>>> lst
deque(['a', 'b', 'c'])
>>> lst.popleft()
'a'
>>> lst
deque(['b', 'c'])
>>> lst.appendleft("a")
>>> lst
deque(['a', 'b', 'c'])
>>> lst.remove("b")
>>> lst
deque(['a', 'c'])
===========================

Implement stack with python provided package

Stack
1) s = []

s.append('eat')
s.append('sleep')
s.append('code')

>>> s
['eat', 'sleep', 'code']

>>> s.pop()
'code'
>>> s.pop()
'sleep'
>>> s.pop()
'eat'

2) 
from collections import deque
>>> s=deque()
>>> s.append(1)
>>> s.append(2)
>>> s.append(3)
>>> s
deque([1, 2, 3])
>>> s.pop()
3
>>> s.pop()
2
>>> s
deque([1])
>>> s
deque([1])
>>> s.append(2)
>>> s
deque([1, 2])
>>> s.pop()
2
>>> s
deque([1])

3) from queue import LifoQueue
s = LifoQueue()

s.put('eat')
s.put('sleep')
s.put('code')

>>> s
<queue.LifoQueue object at 0x108298dd8>

>>> s.get()
'code'
>>> s.get()
'sleep'
>>> s.get()
'eat'
=======================
Implement queue with python provided package

QUEUE
1) q = []

q.append('eat')
q.append('sleep')
q.append('code')

>>> q
['eat', 'sleep', 'code']

# Careful: This is slow!
>>> q.pop(0)
'eat'
2) 
from collections import deque
q = deque()

q.append('eat')
q.append('sleep')
q.append('code')

>>> q
deque(['eat', 'sleep', 'code'])

>>> q.popleft()
'eat'
>>> q.popleft()
'sleep'
>>> q.popleft()
'code'
3) from queue import Queue
q = Queue()

q.put('eat')
q.put('sleep')
q.put('code')

>>> q
<queue.Queue object at 0x1070f5b38>

>>> q.get()
'eat'
>>> q.get()
'sleep'
>>> q.get()
'code'
==================
stack representation of class

class Stack():
	def __init__(self):
		self.items=[]
	def isEmpty(self):
		return self.items == []
	def push(self , a):
		self.items.append(a)
	def peek(self):
		return self.items[len(self.items)-1]
	def pop(self):
		return self.items.pop()
	def size(self):
		return len(self.items)

	
>>> s=Stack()
>>> s.isEmpty()
True
>>> s.push(3)
>>> s.push(True)
>>> s.push("three")
>>> s.peek()
'three'
>>> s.pop()
'three'
>>> s.size()
2

Queue representation of class

class queue():
	def __init__(self):
		self.items=[]
	def enque(self,a):
		self.items.append(a)
	def dequeue(self):
		return self.items.pop(0)
	def isEmpty(self):
		return self.items == []
	def size(self):
		return len(self.items)

	
>>> q=queue()
>>> q.enque(10)
>>> 1.isEmpty()
SyntaxError: invalid syntax
>>> 1.isEmpty()
SyntaxError: invalid syntax
>>> q.isEmpty()
False
>>> q.enque(True)
>>> q.dequeue()
10
>>> q.enque("hello")
>>> q.enque("vijay")
>>> q.dequeue()
True
>>> q.dequeue()
'hello'
>>> q.size()
1
>>> q.dequeue()
'vijay'

=======================
Implement Double ended queue 

class deque():
	def __init__(self):
		self.items=[]
	def isEmpty(self):
		return self.items ==  []
	def addFront(self, a):
		self.items.insert(0,a)
	def addRear(self,a):
		self.items.append(a)
	def removeFront(self):
		return self.items.pop(0)
	def removeRear(self):
		return self.items.pop()
	def size(self):
		return len(self.items)

	
>>> d=deque()
>>> d.addFront(1)
>>> d.addFront(0)
>>> d.removeFront()
0
>>> d.size()
1
======================

Explain functionality of python interpreter

1. Looks at the date/time of your script and checks if there is a .pyc file for your script with a later date than your script; if there then is skip stage 2
2. Read the script line by line and converts that script into python byte code, and then writes the byte code into a pyc file. If your application has mutiple files it creates a pyc file for every .py file. At this stage syntax errors are generated.
3. Load the first pyc file into memory, and then interprets executes the file instruction by instruction, at this stage Runtime errors are created if your code generates such errors. If neccessary then other pyc files are loaded into memory and executed.

============================
what is Pickling 

It is used to serilize and deserialize the python objects
Pickling: It is a process where a Python object is converted into a byte stream.
Unpickling: It is the reverse of Pickling process where a byte stream is converted into an python object.
Module Interface :

dumps() – This function is called to serialize an object.
loads() – This function is called to de-serialize a data stream.


import pickle

a=10
 l=[1,2,4,b"pickle is good" , " python is cooler"]
 d={"vijay" : "TCS",
   "ram": "GOD",
   "Seeta": "Goddess"}
 with open(r'C:\Users\VIJAY\Desktop\mydict.txt', "wb") as f:
	pickle.dump(a, f)   #pickling
	# O/P €K

	with open(r'C:\Users\VIJAY\Desktop\mydict.txt', "rb") as f:
	aa=pickle.load(f)   # unpickling
	# o/p : 10
	
	with open(r'C:\Users\VIJAY\Desktop\mydict.txt', "wb") as f:
	pickle.dump(l , f) # pickling
	
	O/p : €]q (KKKCpickle is goodqX    python is coolerqe.
	
	with open(r'C:\Users\VIJAY\Desktop\mydict.txt', "rb") as f:
	pickle.load(f)  # unpickling

	
O/P : [1, 2, 4, b'pickle is good', ' python is cooler']


	with open(r'C:\Users\VIJAY\Desktop\mydict.txt', "wb") as f:
	pickle.dump(d , f) # pickling
O/P : €}q (X   vijayqX   TCSqX   ramqX   GODqX   SeetaqX   Goddessqu.

with open(r'C:\Users\VIJAY\Desktop\mydict.txt', "rb") as f:
	pickle.load( f) # unpickling

	
O/P : {'vijay': 'TCS', 'ram': 'GOD', 'Seeta': 'Goddess'}

====================================================
what are differet type of operators in Pyton:

1) Arithmetic operators: Arithmetic operators are used to perform mathematical operations like addition, subtraction, multiplication and division.
OPERATOR	DESCRIPTION	SYNTAX
+	Addition: adds two operands	x + y
-	Subtraction: subtracts two operands	x - y
*	Multiplication: multiplies two operands	x * y
/	Division (float): divides the first operand by the second	x / y
//	Division (floor): divides the first operand by the second	x // y
%	Modulus: returns the remainder when first operand is divided by the second	x % y

# Examples of Arithmetic Operator 
a = 9
b = 4
  
# Addition of numbers 
add = a + b 
# Subtraction of numbers  
sub = a - b 
# Multiplication of number  
mul = a * b 
# Division(float) of number  
div1 = a / b 
# Division(floor) of number  
div2 = a // b 
# Modulo of both number 
mod = a % b 
  
# print results 
print(add) 
print(sub) 
print(mul) 
print(div1) 
print(div2) 
print(mod) 
Output:

13
5
36
2.25
2
1


2) Relational Operators: Relational operators compares the values. It either returns True or False according to the condition.
OPERATOR	DESCRIPTION	SYNTAX
>	Greater than: True if left operand is greater than the right	x > y
<	Less than: True if left operand is less than the right	x < y
==	Equal to: True if both operands are equal	x == y
!=	Not equal to - True if operands are not equal	x != y
>=	Greater than or equal to: True if left operand is greater than or equal to the right	x >= y
<=	Less than or equal to: True if left operand is less than or equal to the right	x <= y

# Examples of Relational Operators 
a = 13
b = 33
  
# a > b is False 
print(a > b) 
  
# a < b is True 
print(a < b) 
  
# a == b is False 
print(a == b) 
  
# a != b is True 
print(a != b) 
  
# a >= b is False 
print(a >= b) 
  
# a <= b is True 
print(a <= b) 

Output:

False
True
False
True
False
True

3) Logical operators: Logical operators perform Logical AND, Logical OR and Logical NOT operations.


OPERATOR	DESCRIPTION	SYNTAX
and	Logical AND: True if both the operands are true	x and y
or	Logical OR: True if either of the operands is true	x or y
not	Logical NOT: True if operand is false	not x

# Examples of Logical Operator 
a = True
b = False
  
# Print a and b is False 
print(a and b) 
  
# Print a or b is True 
print(a or b) 
  
# Print not a is False 
print(not a) 
Output:

False
True
False




 

4) Bitwise operators: Bitwise operators acts on bits and performs bit by bit operation.
OPERATOR	DESCRIPTION	SYNTAX
&	Bitwise AND	x & y
|	Bitwise OR	x | y
~	Bitwise NOT	~x
^	Bitwise XOR	x ^ y
>>	Bitwise right shift	x>>
<<	Bitwise left shift	x<<
# Examples of Bitwise operators 
a = 10
b = 4
  
# Print bitwise AND operation   
print(a & b) 
  
# Print bitwise OR operation 
print(a | b) 
  
# Print bitwise NOT operation  
print(~a) 
  
# print bitwise XOR operation  
print(a ^ b) 
  
# print bitwise right shift operation  
print(a >> 2) 
  
# print bitwise left shift operation  
print(a << 2) 
Output:

0
14
-11
14
2
40

5) Assignment operators: Assignment operators are used to assign values to the variables.


OPERATOR	DESCRIPTION	SYNTAX
=	Assign value of right side of expression to left side operand	x = y + z
+=	Add AND: Add right side operand with left side operand and then assign to left operand	a+=b     a=a+b
-=	Subtract AND: Subtract right operand from left operand and then assign to left operand	a-=b       a=a-b
*=	Multiply AND: Multiply right operand with left operand and then assign to left operand	a*=b       a=a*b
/=	Divide AND: Divide left operand with right operand and then assign to left operand	a/=b         a=a/b
%=	Modulus AND: Takes modulus using left and right operands and assign result to left operand	a%=b   a=a%b
//=	Divide(floor) AND: Divide left operand with right operand and then assign the value(floor) to left operand	a//=b       a=a//b
**=	Exponent AND: Calculate exponent(raise power) value using operands and assign value to left operand	a**=b     a=a**b
&=	Performs Bitwise AND on operands and assign value to left operand	a&=b     a=a&b
|=	Performs Bitwise OR on operands and assign value to left operand	a|=b         a=a|b
^=	Performs Bitwise xOR on operands and assign value to left operand	a^=b       a=a^b
>>=	Performs Bitwise right shift on operands and assign value to left operand	a>>=b     a=a>>b
<<=	Performs Bitwise left shift on operands and assign value to left operand	a <<= b                    a= a << b


Special operators: There are some special type of operators like-

6) Identity operators-
is and is not are the identity operators both are used to check if two values are located on the same part of the memory. Two variables that are equal does not imply that they are identical.
is          True if the operands are identical 
is not      True if the operands are not identical 

# Examples of Identity operators 
a1 = 3
b1 = 3
a2 = 'GeeksforGeeks'
b2 = 'GeeksforGeeks'
a3 = [1,2,3] 
b3 = [1,2,3] 
  
  
print(a1 is not b1) 
  
  
print(a2 is b2) 
  
# Output is False, since lists are mutable. 
print(a3 is b3) 
Output:

False
True
False

7) Membership operators-
in and not in are the membership operators; used to test whether a value or variable is in a sequence.
in            True if value is found in the sequence
not in        True if value is not found in the sequence


# Examples of Membership operator 
x = 'Geeks for Geeks'
y = {3:'a',4:'b'} 
  
  
print('G' in x) 
  
print('geeks' not in x) 
  
print('Geeks' not in x) 
  
print(3 in y) 
  
print('b' in y) 
Output:

True
True
False
True
False

===========================================
what is Monkey Patching in Python (Dynamic Behavior)

In Python, the term monkey patch refers to dynamic (or run-time) modifications of a class or module. In Python, we can actually change the behavior of code at run-time.


# monk.py 
class A: 
     def func(self): 
          print "func() is being called"
We use above module (monk) in below code and change behavior of func() at run-time by assigning different value.


import monk 
def monkey_f(self): 
     print "monkey_f() is being called"
   
# replacing address of "func" with "monkey_f" 
monk.A.func = monkey_f 
obj = monk.A() 
  
# calling function "func" whose address got replaced 
# with function "monkey_f()" 
obj.func() 
Examples:

Output :monkey_f() is being called
====================================

how to print last 4 lines of file after removing "\n" from file
with open(r"C:\Users\VIJAY\Desktop\mydict.txt") as f:
    ll=[ x.rstrip() for x in f.readlines()[-4:]]
    print(ll)
==================
how to print first 4 lines of file after removing "\n" from file
with open(r"C:\Users\VIJAY\Desktop\mydict.txt") as f:
    ll=[ x.rstrip() for x in f.readlines()[:4]]
    print(ll)
=======================
print second column in file (space seperated)
print([ x.split()[1] for x in open(r"C:\Users\VIJAY\Desktop\mydict.txt").readlines()])
=======================
print third column in file "|" seperated
print([ x.split("|")[2] for x in open(r"C:\Users\VIJAY\Desktop\mydict.txt").readlines()])
========================
search for a pattern and print the line 
print([x.rstrip() for x in open(r"C:\Users\VIJAY\Desktop\mydict.txt") if "do" in x])
==========================
print no of lines in file
print(len(open(r"C:\Users\VIJAY\Desktop\mydict.txt").readlines()))
=========================
print toatal no of words in file
count=0
with open(r"C:\Users\VIJAY\Desktop\mydict.txt") as f:
    for line in f:
        count+= len(line.split())
print("total words are :",count) 
=========================

print all the lines except line no 2 and 3

with open(r"C:\Users\VIJAY\Desktop\mydict.txt") as f:
    for i ,line in enumerate(f):
        if i >= 1 and i <= 2:
            pass
        else:
            print(line)                 
			
========================
replace file content 'hi' wih 'HI'

with open(r"C:\Users\VIJAY\Desktop\mydict.txt") as f:
    r=f.read().replace("hi","HI")           
with open(r"C:\Users\VIJAY\Desktop\mydict.txt","w") as f:
    f.writelines(r)
	
=======================
replace the string in file, only at line no 1 and 2

with open(r"C:\Users\VIJAY\Desktop\mydict.txt") as f:
    with open(r"C:\Users\VIJAY\Desktop\myopt.txt","w") as ff:
        for i,line in enumerate(f):
            if i>=0 and i<=1:
                r=line.replace('hi',"HI")
                ff.writelines(r)
            else:
                ff.writelines(line)   
				
				
======================
append string "end"  at end of every line

s="end"
with open(r"C:\Users\VIJAY\Desktop\mydict.txt") as fin:
    with open(r"C:\Users\VIJAY\Desktop\myopt.txt" , "w") as fout:
        for line in fin:
            fout.write(line.rstrip("\n") + s+ "\n")
print(open(r"C:\Users\VIJAY\Desktop\myopt.txt").readlines())	

======================
how to take command line input from user

import sys

program_name=sys.argv[0]
print("name of program is {}".format(program_name))
print("arguments passed to program are as follows")
for x in sys.argv[1:]:
     print(x)

===============
what is usage of *args and **kwargs ?

def person(name , *data):
    print("name :",name)
    for info in data:
        print(info)
person("vijay" , "bhadup" , "tcs")


def person_kwargs(name , **data):
    print("name is:",name)
    for key , value in data.items():
        print(key,value)

person_kwargs("vijay"  , company="tcs" , hometown="bhandup" , phone=9588756746)

======================
https://www.geeksforgeeks.org/__name__-a-special-variable-in-python/
case1) if you are printing __name__ in current program then it will print as "__main__"

case2) in one program you are  printing __name__ and importing that program into another program then over there instead of printing "__main__" it will print the name of program which was imported
===========================
implement Multithreading in python 

from threading import *
from time import *

class Hello(Thread):
    def run(self):
        for i in range(15):
            print("hello")

class Hi(Thread):
    def run(self):
        for i in range(15):
            print("hi")


t1=Hello()
t2=Hi()

t1.start()
t2.start()

t1.join()
t2.join()
print("bye")
                    


here because of join method main thread will wait for t1 to complete and t2 to complete and main thread will proceed to print "bye"

=============================
what are different list methods

s=[1,2,3,4]
1) append():
it is used to append at th end of list

2) insert(position , element)
s.insert(1 , 1.5)
>>> s
[1, 1.5, 2, 3, 4]

3) list1.extend(list2)
Adds contents to List2 to the end of List1.


List1 = [1, 2, 3] 
List2 = [2, 3, 4] 
  
# Add List2 to List1 
List1.extend(List2)

o/p : [1,2,3,2,3,4]


4) sum(List)
Calculates sum of all the elements of List.

5) count():Calculates total occurrence of given element of List.
List = [1, 2, 3, 1, 2, 1, 2, 3, 2, 1] 
print(List.count(1))

o/p : 5

6) len(list_name) : Calculates total length of Lis

7) List.index(element[,start[,end]])

List = [1, 2, 3, 1, 2, 1, 2, 3, 2, 1] 
  
# will check from index 2 to 5. 
print(List.index(2,2,6))

8) min() : Calculates minimum of all the elements of List.

9) max(): Calculates maximum of all the elements of List.

10) list.sort() : it will sort in ascending order
list.sort(reverse=True) : it will sort in desceding order

11) pop(index) : index is not necessary parameter , if index not specified then removed last element from list else removes index elemet from list

List = [2.3, 4.445, 3, 5.33, 1.054, 2.5] 
print(List.pop()) 
print(List.pop(0))

o/p : 2.5
2.3

12) del :  used to delete element
del List[0] : deleted first element

del List : deletes entire list

=========================
what is differences between Python 2.x and Python 3.x ?
 1) Division Operator
 print 7 / 5
   
Output in Python 2.x // When two integers are divided, you always provide integer value.
1 

Output in Python 3.x : //Whenever two integers are divided, you get a float value
1.4 

2) print() function
print 'Hello, Geeks'  // python 2 supports this , 3 doesn't supports
print('Hope You like these facts')  // python 3 supports this


3) xrange() of Python 2.x doesn’t exist in Python 3.x

4) "as" keyword is needed in exception handling

try: 
    trying_to_check_error 
except NameError, err: 
    print err, 'Error Caused'   # Would not work in Python 3.x , it works in python 2
	
	
try: 
     trying_to_check_error 
except NameError as err: # 'as' is needed in Python 3.x 
     print (err, 'Error Caused') 
=================================
t=(1, 2, [3, 4])
can we update the third index of this tuple
yes we can update by following way
t[2][0]=0
print(t)
(1, 2, [0, 4])

================
what all data types can be a key in dictionary ?
>>> d={}
>>> d[1]=1
>>> import sys
>>> d[sys] = "sys"
>>> d[(1,2)]=(1,2)
>>> d[(1,[2])]=(1,[2]) // error
================
MRO :
refer below link for MRO

http://www.srikanthtechnologies.com/blog/python/mro.aspx
======
what is Decorator :
it allows programmers to modify the behavior of function or class. Decorators allow us to wrap another function in order to extend the behavior of wrapped function, without permanently modifying it.

In Decorators, functions are taken as the argument into another function and then called inside the wrapper function.

def hello_decorator(func): 

    def inner1(): 
        print("Hello, this is before function execution") 
        func()   
        print("This is after function execution") 
          
    return inner1 
  
  
# defining a function, to be called inside wrapper 
def function_to_be_used(): 
    print("This is inside the function !!") 
  
function_to_be_used = hello_decorator(function_to_be_used) 
  
function_to_be_used() 
Output:

Hello, this is before function execution
This is inside the function !!
This is after function execution
======================
does python supports Method overloading?

python does not supports method overloading. We may overload the methods but can only use the latest defined method.

def product(a, b): 
    p = a * b 
    print(p) 
      
# Second product method 
# Takes three argument and print their 
# product 
def product(a, b, c): 
    p = a * b*c 
    print(p) 
  
# Uncommenting the below line shows an error     
# product(4, 5) 
  
# This line will call the second product method 
product(4, 5, 5)

Output:
100


# Function to take multiple arguments 
def add(datatype, *args): 
  
    # if datatype is int 
    # initialize answer as 0 
    if datatype =='int': 
        answer = 0
          
    # if datatype is str 
    # initialize answer as '' 
    if datatype =='str': 
        answer ='' 
  
    # Traverse through the arguments 
    for x in args: 
  
        # This will do addition if the  
        # arguments are int. Or concatenation  
        # if the arguments are str 
        answer = answer + x 
  
    print(answer) 
  
# Integer 
add('int', 5, 6) 
  
# String 
add('str', 'Hi ', 'Geeks') 

Output:
11
Hi Geeks
=============
1) how to combine 2 lists into 1 nested list 

l1=[1, 2, 3, 4] 
l2=[11, 22, 33, 44]
ll=list(zip(l1,l2))
print(ll)
[(1, 11), (2, 22), (3, 33), (4, 44)]

>>> p1,p2=zip(*ll)
>>> p1
(1, 2, 3, 4)
>>> p2
(11, 22, 33, 44)

ZIP usage

ll=zip(l)

>>> list(ll)
[(1,), (2,), (3,), (4,)]  // if we are passing only single list then in this way tuple will form

>>> l2=["one" , "two" , "three"]
>>> ll=zip(l,l2)
>>> list(ll)
[(1, 'one'), (2, 'two'), (3, 'three')]

create a dictionary from two lists
l1=[1,2,3]
l2=['one','two','three']

d=dict(zip(l1,l2))
>>> d
{1: 'one', 2: 'two', 3: 'three'}


from itertools import cycle 
  
# initializing lists 
test_list1 = [7, 8, 4, 5, 9, 10] 
test_list2 = [1, 5, 6] 
  
# printing original lists 
print ("The original list 1 is : " + str(test_list1)) 
print ("The original list 2 is : " + str(test_list2)) 
  
# using itertools.cycle() 
# zipping of two different size list  
res = list(zip(test_list1, cycle(test_list2)) 
            if len(test_list1) > len(test_list2) 
            else zip(cycle(test_list1), test_list2)) 
  
# printing result  
print ("The zipped list is : " +  str(res)) 
Output:
The original list 1 is : [7, 8, 4, 5, 9, 10]
The original list 2 is : [1, 5, 6]
The zipped list is : [(7, 1), (8, 5), (4, 6), (5, 1), (9, 5), (10, 6)]

=============
what is o/p of below code:
l1=[1,2,3,4]
>>> l2=["one","two"]
>>> z=zip(l1,l2)
>>> dict(z)

O/P is 
{1: 'one', 2: 'two'}
===============

2) print odd numbers between 1 to 10

print([ i for i in range(1,11,2)])


======================
how to copy content of one dir to another directory ?

copy operation with shutil 
import os
import shutil

>>> def copy(src,dest):
	for file in os.listdir(src):
		full_path=os.path.join(src,file)
		shutil.copy(full_path,dest)
		
copy(r"C:\Users\VIJAY\Desktop\data" , r"C:\Users\VIJAY\Desktop\dattavadhut swami")

====================

how to move content of one directory into another ?
move files from one to other directory 

>>> def move(src,dest):
	for file in os.listdir(src):
		full_path=os.path.join(src,file)
		shutil.move(full_path,dest)
		
move(r"C:\Users\VIJAY\Desktop\data" , r"C:\Users\VIJAY\Desktop\dattavadhut swami")

============

Random module :
import random

random.random()  // create a random float between (0,1]
0.35699405312267074

random.uniform(1,10)  // creates a random float betwen 1,10
5.722263354698193

random.randrange(20)  // creates a random integer between (0,20]
7

random.randrange(0,20) // creates a random integer between (0,20]
8

random.randint(0,5)  //  creates a random integer between (0,5)
5 

difference between randint (a,b) and randrange(a,b) is that 
randint will include a to b but randrange will include a to b-1

random.randrange(1,20,2)  // prints odd random integer between 1 to 19
15

random.randrange(0,20,1)  // prints even random integer between 0 to 19
6

l=[1,2,3,4]
>>> random.choice(l)  prints random element from list
3
>>> random.choice(l)
1
>>> random.shuffle(l)  // shuffles list randomly
>>> l
[3, 4, 2, 1]
>>> random.shuffle(l)
>>> l
[2, 3, 4, 1]

===========

any() returns:

True if at least one element of an iterable is true
False if all elements are false or if an iterable is empty

All values are true	True
All values are false	False
One value is true (others are false)	True
One value is false (others are true)	True
Empty Iterable	False

all() method returns:

True - If all elements in an iterable are true
False - If any element in an iterable is false

All values are true	True
All values are false	False
One value is true (others are false)	False
One value is false (others are true)	False
Empty Iterable	True

==============
what is o/p of below code:
numbers = [1, 2, 3, 4, 5, 6]

# The left side of unpacking should be list or tuple.
*a, = numbers
o/p : a = [1, 2, 3, 4, 5, 6]

*a, b = numbers
o/p  a = [1, 2, 3, 4, 5]
o/p  b = 6

a, *b, = numbers
o/p  a = 1 
o/p  b = [2, 3, 4, 5, 6]

a, *b, c = numbers
o/p a = 1
o/p b = [2, 3, 4, 5]
o/p c = 6

=============
take a list as input to function for ex s=[1,2,3,4,5]
then write following content into a file C:\Users\VIJAY\Desktop\file.txt
1
2
3
4
5

def test(s):
	ss=""
	for i in s:
		ss+=str(str(i)+"\n")
	with open(r"C:\Users\VIJAY\Desktop\file.txt","w") as f:
		f.writelines(ss)
=====================
what is o/p of below code:

 def test(n,l=[2,3,4]):
	l.append(n)
	print(l)
	
test(2)
test(5,[1,2,3,4])
test(3)

o/p : [2,3,4,2]
o/p : [1,2,3,4,5]
o/p : [ 2, 3, 4, 2, 3]

==================
what is o/p of below code:
>> var='a'
>>> l=[]
>>> l.append(var)
>>> new_l=l
>>> new_l.append('b')
>>> var='c'
 print(l)
 print(new_l)
 print(var)

o/p :
['a','b']
['a','b']
c
====================
==================
what is difference between instace, class and static methods

class  Student:
	school = 'Vijay School'
	def __init__(self, m1, m2, m3):
		self.m1 = m1
		self.m2 = m2
		self.m3 = m3
	def avg(self):
		return (self.m1+self.m2+self.m3)/3
	@classmethod
	def getschoolname(cls):
		return cls.school
	@staticmethod
	def info():
		print("this is Student class in student module")

		
>>> s1=Student(9,8,7)
>>> s1.avg()
8.0
>>> Student.getschoolname()
'Vijay School'
>>> Student.info()
this is Student class in student module


instance method deals with instance variables , class method deals with class variables , those variables which are declared outside of a method are said to be class method.
if there is any method which doesn't want to use instance and class variables then that method is static method

=========================================
what is context manager in Python ?

context manager:
 In any programming language, the usage of resources like file operations or database connections is very common. But these resources are limited in supply. Therefore, the main problem lies in making sure to release these resources after usage. If they are not released then it will lead to resource leakage and may cause the system to either slow down or crash. It would be very helpful if user have a mechanism for the automatic setup and teardown of resources.In Python, it can be achieved by the usage of context managers which facilitate the proper handling of resources

When creating context managers using classes, user need to ensure that the class has the methods: __enter__() and __exit__(). The __enter__() returns the resource that needs to be managed and the __exit__() does not return anything but performs the cleanup operations.

class FileManager(): 
    def __init__(self, filename, mode): 
        self.filename = filename 
        self.mode = mode 
        self.file = None
          
    def __enter__(self): 
        self.file = open(self.filename, self.mode) 
        return self.file
      
    def __exit__(self, exc_type, exc_value, exc_traceback): 
        self.file.close() 
  
# loading a file  
with FileManager('test.txt', 'w') as f: 
    f.write('Test') 
  
print(f.closed) 
Output:

True
 
File management using context manager and with statement :

On executing the with block, the following operations happen in sequence:

A FileManager object is created with test.txt as the filename and w(write) as the mode when __init__ method is executed.
The __enter__ method opens the test.txt file in write mode(setup operation) and returns the FileManager object to variable f.
The text ‘Test’ is written into the file.
The __exit__ method takes care of closing the file on exiting the with block(teardown operation).
When print(f.closed) is run, the output is True as the FileManager has already taken care of closing the file which otherwise needed to be explicitly done.

https://www.geeksforgeeks.org/context-manager-in-python/

======================

what is difference between __del__ and __delete__ method ?
__del__ is a destructor method which is called as soon as all references of the object are deleted i.e when an object is garbage collected.


class Example: 
	
	# Initializing 
	def __init__(self): 
		print("Example Instance.") 

	# Calling destructor 
	def __del__(self): 
		print("Destructor called, Example deleted.") 
	
obj = Example() 
del obj 

O/: 
Example Instance.
Destructor called, Example deleted.

__delete__:
__delete__ is used to delete the attribute of an instance i.e removing the value of attribute present in the owner class for an instance.


class Example(object): 
  
    # Initializing 
    def __init__(self): 
        print("Example Instance.") 
  
    # Calling __delete__ 
    def __delete__(self, instance): 
        print ("Deleted in Example object.") 
  
  
# Creating object of Example 
# class as an descriptor attribute 
# of this class 
class Foo(object): 
    exp = Example() 
  
# Driver's code 
f = Foo() 
del f.exp 


Output:
Example Instance.
Deleted in Example object.

difference : 
__delete__ 												__del__
it is used to delete attribute of a class 				It is used as destructor
need to called explicitly  								gets called implicitly
executed before program ends							executed after program ends


combination of __del__ and __delete__
# Python program to demonstrate 
# __del__ and __delete__ 


class Example(object): 

	# Initializing 
	def __init__(self): 
		self.value = '' 

	# deletes an attribute 
	def __delete__(self, instance): 
		print ("Inside __delete__") 
		
	# Destructor 
	def __del__(self): 
		print("Inside __del__") 
	
	
class Foo(object): 
	exp = Example() 

# Driver's code 
f = Foo() 
del f.exp 

Output:

Inside __delete__
Inside __del__


======================
dictionary methods
1) update

# Python program to show working 
# of update() method in Dictionary 

# Dictionary with three items 
Dictionary1 = { 'A': 'Geeks', 'B': 'For', } 
Dictionary2 = { 'B': 'Geeks' } 

# Dictionary before Updation 
print("Original Dictionary:") 
print(Dictionary1) 

# update the value of key 'B' 
Dictionary1.update(Dictionary2) 
print("Dictionary after updation:") 
print(Dictionary1) 

o/p:
Original Dictionary:
{'A': 'Geeks', 'B': 'For'}

Dictionary after updation:
{'A': 'Geeks', 'B': 'Geeks'}

# Python program to show working 
# of update() method in Dictionary 

# Dictionary with single item 
Dictionary1 = { 'A': 'Geeks'} 

# Dictionary before Updation 
print("Original Dictionary:") 
print(Dictionary1) 

# update the Dictionary with iterable 
Dictionary1.update(B = 'For', C = 'Geeks') 
print("Dictionary after updation:") 
print(Dictionary1) 

Output:

Original Dictionary:
{'A': 'Geeks'}

Dictionary after updation:
{'C': 'Geeks', 'B': 'For', 'A': 'Geeks'}


2) setdefault(): method returns the value of a key (if the key is in dictionary). If not, it inserts key with a value to the dictionary.

Returns:
Value of the key if it is in the dictionary.
None if key is not in the dictionary and default_value is not specified.
default_value if key is not in the dictionary and default_value is specified.

Dictionary1 = { 'A': 'Geeks', 'B': 'For'} 
  
Third_value = Dictionary1.setdefault('C') 
print("Dictionary:", Dictionary1) 
print("Third_value:", Third_value) 
  
Fourth_value = Dictionary1.setdefault('D', 'Geeks') 
print("Dictionary:", Dictionary1) 
print("Fourth_value:", Fourth_value) 

Output:

Dictionary: {'A': 'Geeks', 'B': 'For', 'C': None}
Third_value: None
Dictionary: {'A': 'Geeks', 'B': 'For', 'C': None, 'D': 'Geeks'}
Fourth_value: Geeks


3) fromkeys :
It Return a dictionary with keys mapped to None if no value is provided, else to the value provided in the field.

l=[1,2]
d=dict.fromkeys(l)
>>> d
{1: None, 2: None}
>>> dd=dict.fromkeys(l,0)
>>> dd
{1: 0, 2: 0}

============================
Local, Global and non Local variable

https://www.geeksforgeeks.org/global-local-variables-python/

a = 1
  
# Uses global because there is no local 'a' 
def f(): 
    print 'Inside f() : ', a 
  
# Variable 'a' is redefined as a local 
def g():     
    a = 2
    print 'Inside g() : ',a 
  
# Uses global keyword to modify global 'a' 
def h():     
    global a 
    a = 3
    print 'Inside h() : ',a 
  
# Global scope 
print 'global : ',a 
f() 
print 'global : ',a 
g() 
print 'global : ',a 
h() 
print 'global : ',a 
Output:

global :  1
Inside f() :  1
global :  1
Inside g() :  2
global :  1
Inside h() :  3
global :  3

NonLocal variable
https://www.geeksforgeeks.org/use-of-nonlocal-vs-use-of-global-keyword-in-python/

def fun(): 
    var1 = 10
  
    def gun(): 
        # tell python explicitly that it  
        # has to access var1 initialized  
        # in fun on line 2 
        # using the keyword nonlocal 
        nonlocal var1 
        var1 = var1 + 10
        print(var1) 
  
    gun() 
fun() 
Output:
20
In this example, before initializing var1 in gun(). We have explicitly told Python that, do not initialize a new variable, instead access var1 present already on line 2. using the keyword nonlocal So when interpreter performs addition, it access the value 10(already present) and error is avoided.

=======================
fetch specific portion of logfile based on date
I would like to print only lines with dates from: 2012/09/30-00:00:10 to: 2012/09/30-00:00:13

2012/09/30-00:00:08.773 log error
2012/09/30-00:00:09.034 log warning
2012/09/30-00:00:09.352 log info
2012/09/30-00:00:10.526 log info
2012/09/30-00:00:10.995 log warning
2012/09/30-00:00:12.014 log warning
2012/09/30-00:00:18.035 log error
2012/09/30-00:00:21.733 log fatal
2012/09/30-00:00:21.981 log info
It should print:

2012/09/30-00:00:10.526 log line
2012/09/30-00:00:10.995 log line
2012/09/30-00:00:12.014 log line

ANS:

way 1) 
Actullay, the log format allows to compare date strings without their conversion to datetime.

with open('mylog.log','r') as f:
    for line in f:
        d = line.split(" ")[0] 
        if d >= '2012/09/30-00:00:10' and d <= '2012/09/30-00:00:13':
            print lines
			
way 2) 
import re
for line in log:
    if re.match("2012/09/30-00:00:1[0-3]", line):
        print line
		
============================
Iterator in python is any python type that can be used with a ‘for in loop’. Python lists, tuples, dicts and sets are all examples of inbuilt iterators. These types are iterators because they implement following methods. In fact, any object that wants to be an iterator must implement following methods.

__iter__ method that is called on initialization of an iterator. This should return an object that has a next or __next__ (in Python 3) method.
next ( __next__ in Python 3) The iterator next method should return the next value for the iterable. When an iterator is used with a ‘for in’ loop, the for loop implicitly calls next() on the iterator object. This method should raise a StopIteration to signal the end of the iteration.

class Test: 
  
    def __init__(self, limit): 
        self.limit = limit 
  
    def __iter__(self): 
        self.x = 10
        return self
  
    def __next__(self):
        x = self.x 
 
        if x > self.limit: 
            raise StopIteration 
  
        # Else increment and return old value 
        self.x = x + 1; 
        return x 
  
# Prints numbers from 10 to 15 
for i in Test(15): 
    print(i) 
  
# Prints nothing 
for i in Test(5): 
    print(i)
    
Output :
10
11
12
13
14
15

=======================
Generator :
https://www.geeksforgeeks.org/generators-in-python/

Generator-Function : A generator-function is defined like a normal function, but whenever it needs to generate a value, it does so with the yield keyword rather than return. If the body of a def contains yield, the function automatically becomes a generator function.

def simpleGeneratorFun(): 
    yield 1            
    yield 2            
    yield 3            
   
# Driver code to check above generator function 
for value in simpleGeneratorFun():  
    print(value) 
Output :

1
2
3

Generator-Object : Generator functions return a generator object. Generator objects are used either by calling the next method on the generator object or using the generator object in a “for in” loop (as shown in the above program).

# A Python program to demonstrate use of  
# generator object with next()  
  
# A generator function 
def simpleGeneratorFun(): 
    yield 1
    yield 2
    yield 3
   
# x is a generator object 
x = simpleGeneratorFun() 
  
# Iterating over the generator object using next 
print(x.next()) 
print(x.next()) 
print(x.next()) 
Output :

1
2
3

So a generator function returns an generator object that is iterable, i.e., can be used as an Iterators .
==============================


Is Python call by value or call by reference ?
https://medium.com/@lokeshsharma596/is-python-call-by-value-or-call-by-reference-2dd7db74dbd0


Call/Pass By Value:
In pass-by-value, the function receives a copy of the argument objects passed to it by the caller, stored in a new location in memory.
You pass values of parameter to the function,if any kind of change done to those parameters inside the function ,those changes not reflected back in your actual parameters.
Call By Reference:
In pass-by-reference, the function receives reference to the argument objects passed to it by the caller, both pointing to the same memory location.
you pass reference of parameters to your function.if any changes made to those parameters inside function those changes are get reflected back to your actual parameters.
In Python Neither of these two concepts are applicable, rather the values are sent to functions by means of object reference.
Pass-by-object-reference:
In Python, (almost) everything is an object. What we commonly refer to as “variables” in Python are more properly 
called names. Likewise, “assignment” is really the binding of a name to an object. Each binding has a scope that defines its visibility, usually the block in which the name originates.
In Python,Values are passed to function by object reference.
if object is immutable(not modifiable) than the modified value is not available outside the function.
if object is mutable (modifiable) than modified value is available outside the function.
Mutable objects:
list, dict, set, byte array
Immutable objects:
int, float, complex, string, tuple, frozen set

def val(x):
x=15
print(x,id(x))

x = 10
val(x)
print(x,id(x))


a new object is creted into memory because integer objects are immutable

def val(x):
x.append(4)
print(x,id(x))

x=[1,2,3]
val(x)
print(x,id(x))

a new object is not created into memory bcoz list objects are mutable , it simply add new element to same object.

==========================
what is difference between package and module in python ?

A package is a collection of Python modules: while a module is a single Python file, a package is a directory of Python modules containing an additional __init__.py file

===================

what is difference between append and extend ?

l=[1,2,3]
>>> l.append(4)
>>> l
[1, 2, 3, 4]
>>> l.append([5,6])
>>> l
[1, 2, 3, 4, [5, 6]]
>>> l.extend(7)
Traceback (most recent call last):
  File "<pyshell#229>", line 1, in <module>
    l.extend(7)
TypeError: 'int' object is not iterable
>>> l.extend([7])
>>> l
[1, 2, 3, 4, [5, 6], 7]
>>> l.extend([8,9])
>>> l
[1, 2, 3, 4, [5, 6], 7, 8, 9]

Append : IT considers argument of append as single element that can be integer or list and appends to original list.
by appending size of originial list always increases by 1

extend :We can pass arguments to extend in list only number as argument is not allowed. there can be single or multiple values present into argument list.by extending the size of original list can be increase by 1 or more.

==============
difference between multithreading and multiprocessing ?

A multiprocessing system has more than two processors whereas Multithreading is a program execution technique that allows a single process to have multiple code segments. Multiprocessing improves the reliability of the system while in the multithreading process, each thread runs parallel to each other

=================
print odd  rows from file in python 

with open(r'C:\Users\VIJAY\Desktop\test.txt') as f:
	data=f.readlines()
	
for i in range(0, len(data),2):
	print(i)

===========================
how to specify two conditions in list comprehension
>>> l=[1,2,3,4,5,6,7,8,9]
>>> [i for i in l if i%2 == 0 and i%3 == 0]
[6]


how to specify if else condition in list comprehension
n=[1, 2, 3, 4, 5]
print([i if i%2 == 0 else 99 for i in n])
[99, 2, 99, 4, 99]

========================
what is more faster for loop or list comprehension ?
Python list comprehension is faster than plain loops. List comprehension is optimized for Python interpreter.
 

import timeit
TEST_CODE1 = '''
mylist = [x * 2 for x in range(100)]
'''
TEST_CODE2 = '''
mylist = []
for x in range(100):
	mylist.append(x*2)
'''
timeit.timeit(stmt=TEST_CODE1, number=10000)
timeit.timeit(stmt=TEST_CODE2, number=10000)

O/P:
>>> timeit.timeit(stmt=TEST_CODE1, number=100)
0.003901347999999416
>>> timeit.timeit(stmt=TEST_CODE2, number=100)
0.006439930999931676

==========================
what happends when read() function is executed twice on file ?
ANS : in first read() entire file is returned in form of string for second read() nothing is returned even error is not returned.


>>> with open(r'C:\Users\VIJAY\Desktop\test.txt', 'r')as f:
	print(f.read())
	print("hello")
	f.seek(0)
	print(f.read())

	
vijay;bhalekar;23/4;shivashram;bhandup;mumbai;here
ajay;bhalekar;23/5;shivashram;bhandup;mumbai;there
swati;bhalekar;23/6;shivashram;bhandup;mumbai;here


hello
0

============================
how to replace the word "nahur" with "bhandup" present in file python ( source and destination file should be same)

>>> def test():
	with open(r'C:\Users\VIJAY\Desktop\test.txt' ,'r') as f:
		data=f.read()
	with open(r'C:\Users\VIJAY\Desktop\test.txt' ,'w+') as f:
		f.writelines(data.replace('nahur','bhandup'))
		



=======================
json module


d= {'c': 'CC', 'd': 'dd', 'b': 'BB'}

dd=json.dumps(d, sort_keys=True, indent=2, separators=(" . "," = "))
>>> dd
'{\n  "b" = "BB" . \n  "c" = "CC" . \n  "d" = "dd"\n}'

read file by json package

emp.json
{
    "emp_details": [
	    { 
		    "emp_name": "vijay",
			"emp_email": "bb@gmail.com",
			"designation": "developer"
		},
		{
		    "emp_name": "ajay",
			"emp_email": "aa@gmail.com"
		}
	]	

}


# Python program to read
# json file


import json

# Opening JSON file
f=open(r"C:\Users\Vijay\Desktop\emp.json",)

# returns JSON object as
# a dictionary
data = json.load(f)

# Iterating through the json
# list
for i in data['emp_details']:
	print(i)

# Closing file
f.close()

o/p:
	
{'emp_name': 'vijay', 'emp_email': 'bb@gmail.com', 'designation': 'developer'}
{'emp_name': 'ajay', 'emp_email': 'aa@gmail.com'}



=========
write json to file

import json

person_dict = {"name": "Bob",
"languages": ["English", "Fench"],
"married": True,
"age": 32
}

with open('person.txt', 'w') as json_file:
  json.dump(person_dict, json_file)
  
===================

CSV Module

read a csv file
# importing csv module
import csv

# csv file name
filename = "aapl.csv"

# initializing the titles and rows list
fields = []
rows = []

# reading csv file
with open(filename, 'r') as csvfile:
	# creating a csv reader object
	csvreader = csv.reader(csvfile)
	
	# extracting field names through first row
	fields = next(csvreader)

	# extracting each data row one by one
	for row in csvreader:
		rows.append(row)

	# get total number of rows
	print("Total no. of rows: %d"%(csvreader.line_num))

# printing the field names
print('Field names are:' + ', '.join(field for field in fields))

# printing first 5 rows
print('\nFirst 5 rows are:\n')
for row in rows[:5]:
	# parsing each column of a row
	for col in row:
		print("%10s"%col),
	print('\n')


============
write to csv file

# importing the csv module
import csv

# field names
fields = ['Name', 'Branch', 'Year', 'CGPA']

# data rows of csv file
rows = [ ['Nikhil', 'COE', '2', '9.0'],
		['Sanchit', 'COE', '2', '9.1'],
		['Aditya', 'IT', '2', '9.3'],
		['Sagar', 'SE', '1', '9.5'],
		['Prateek', 'MCE', '3', '7.8'],
		['Sahil', 'EP', '2', '9.1']]

# name of csv file
filename = "university_records.csv"

# writing to csv file
with open(filename, 'w') as csvfile:
	# creating a csv writer object
	csvwriter = csv.writer(csvfile)
	
	# writing the fields
	csvwriter.writerow(fields)
	
	# writing the data rows
	csvwriter.writerows(rows)

======
write multiple rows to file with csv, read from dict
# importing the csv module
import csv

# my data rows as dictionary objects
mydict =[{'branch': 'COE', 'cgpa': '9.0', 'name': 'Nikhil', 'year': '2'},
		{'branch': 'COE', 'cgpa': '9.1', 'name': 'Sanchit', 'year': '2'},
		{'branch': 'IT', 'cgpa': '9.3', 'name': 'Aditya', 'year': '2'},
		{'branch': 'SE', 'cgpa': '9.5', 'name': 'Sagar', 'year': '1'},
		{'branch': 'MCE', 'cgpa': '7.8', 'name': 'Prateek', 'year': '3'},
		{'branch': 'EP', 'cgpa': '9.1', 'name': 'Sahil', 'year': '2'}]

# field names
fields = ['name', 'branch', 'year', 'cgpa']

# name of csv file
filename = "university_records.csv"

# writing to csv file
with open(filename, 'w') as csvfile:
	# creating a csv dict writer object
	writer = csv.DictWriter(csvfile, fieldnames = fields)
	
	# writing headers (field names)
	writer.writeheader()
	
	# writing data rows
	writer.writerows(mydict)

=======

$ pip install virtualenv


$ virtualenv --version

$ virtualenv my_name

$ source virtualenv_name/bin/activate

(virtualenv_name)$ deactivate

===========
memory manaement in python 
https://www.squash.io/how-to-manage-memory-with-python/#:~:text=In%20Python%2C%20memory%20management%20is,are%20no%20longer%20in%20use.

name variables ( reference variables) gets memory in stack space
x=10
here x is stored in stack 
in actuall reference of memory is stored at stack space 
Methods are executed from stack memory 
methods and variables are created on stack memory 
new stack frame is created on invocation of new method 
stack frames are destroyed as soon as method is returned 


private Heap space
we are not allowed to directly access this space 
we can access this by only its id ( reference ) 


Garbage collection is mechanism to cleanup the dead objects 

===========
difference between list and tuple 


both can store heterogenous item, support indexing, support slicing, support  
list is mutable and tuple is immutable

we should use list in case we are going to use insertion , updation , deletion frequently 
in case we are supposed to only access then use tuple 

tuple provides count and index only 

==========
what is identity operator 

1) is 
2) is not 

x=10
y=10

print(x is y)
True

in case address of x and y is same then it return True 

============
what is monkey patching 

dynamic replacement of attribute at runtime 
changing behaviour of class at runtime 

class test:
	def __init__(self,x):
		self.a=x
	def get_data(self):
		print("some code to fetch data from db")
	def f1(self):
		self.get_data()
	def f2(self):
		self.get_data()

		
>>> t1=test(2)
>>> t1.f1()
some code to fetch data from db
>>> t1.f2()
some code to fetch data from db
>>> def new_get_data(self):
	print("new code to fetch data from db")

	
>>> test.get_data=new_get_data
>>> t1.f1()
new code to fetch data from db
>>> t1.f2()
new code to fetch data from db

=============

print first 10 prime numbers with help of generator

def isPrime(num):
	for i  in range(2,num):
		if num%2 == 0:
			return False
	return True
	
def primegenerator(num):
	n=2
	while num:
		if isPrime(n):
			yield n
			num-=1
		n+=1
	return
it=primegenerator(10)

for i in it:
	print(i,end=" ,")

============
============
Operator Overloading means giving extended meaning beyond their predefined operational meaning. For example operator + is used to add two integers as well as join two strings and merge two lists. It is achievable because ‘+’ operator is overloaded by int class and str class. You might have noticed that the same built-in operator or function shows different behavior for objects of different classes, this is called Operator Overloading. 
 
 
 Consider that we have two objects which are a physical representation of a class (user-defined data type) and we have to add two objects with binary ‘+’ operator it throws an error, because compiler don’t know how to add two objects. So we define a method for an operator and that process is called operator overloading. We can overload all existing operators but we can’t create a new operator. To perform operator overloading, Python provides some special function or magic function that is automatically invoked when it is associated with that particular operator. For example, when we use + operator, the magic method __add__ is automatically invoked in which the operation for + operator is defined.
 
class A:
    def __init__(self, a):
        self.a = a
 
    # adding two objects
    def __add__(self, o):
        return self.a + o.a
ob1 = A(1)
ob2 = A(2)
ob3 = A("Geeks")
ob4 = A("For")
 
print(ob1 + ob2)
print(ob3 + ob4)


class A:
    def __init__(self, a):
        self.a = a
    def __gt__(self, other):
        if(self.a>other.a):
            return True
        else:
            return False
ob1 = A(2)
ob2 = A(3)
if(ob1>ob2):
    print("ob1 is greater than ob2")
else:
    print("ob2 is greater than ob1")
	
Operator	Magic Method
+	__add__(self, other)
–	__sub__(self, other)
*	__mul__(self, other)
/	__truediv__(self, other)
//	__floordiv__(self, other)
%	__mod__(self, other)
**	__pow__(self, other)
>>	__rshift__(self, other)
<<	__lshift__(self, other)
&	__and__(self, other)
|	__or__(self, other)
^	__xor__(self, other)
Comparison Operators :
Operator	Magic Method
<	__LT__(SELF, OTHER)
>	__GT__(SELF, OTHER)
<=	__LE__(SELF, OTHER)
>=	__GE__(SELF, OTHER)
==	__EQ__(SELF, OTHER)
!=	__NE__(SELF, OTHER)
Assignment Operators :
Operator	Magic Method
-=	__ISUB__(SELF, OTHER)
+=	__IADD__(SELF, OTHER)
*=	__IMUL__(SELF, OTHER)
/=	__IDIV__(SELF, OTHER)
//=	__IFLOORDIV__(SELF, OTHER)
%=	__IMOD__(SELF, OTHER)
**=	__IPOW__(SELF, OTHER)
>>=	__IRSHIFT__(SELF, OTHER)
<<=	__ILSHIFT__(SELF, OTHER)
&=	__IAND__(SELF, OTHER)
|=	__IOR__(SELF, OTHER)
^=	__IXOR__(SELF, OTHER)
Unary Operators :
Operator	Magic Method
–	__NEG__(SELF, OTHER)
+	__POS__(SELF, OTHER)
~	__INVERT__(SELF, OTHER)
============
2 ,3 ,5 ,7 ,9 ,11 ,13 ,15 ,17 ,19 ,

==========
factorial of n using lambda 
f=lambda n: 1 if n ==0 else n*f(n-1)
f(4)

=============
what is difference between sorted and sort

sorted is applciable on all iterables, it always returns a list, it doesnt make change in existing data structure , it creates new list with sorted element
sort is only for list , it make changes in existing list only , it return None
============
define custom exception 

class ValueTooSmall(Exception):
	pass
	
	
while True:
	try:
		num=int(input("enter numebr "))
		if num < n:
			raise ValueTooSmall
			
	except ValueTooSmall:
		print("error here")
		break

	
enter numebr 3
error here
===================

class a:
	def foo(a,*args):
		print("A")

		
>>> class b:
	def foo(a,b):
		print("b")


class c(a,b):
	pass

>>> cc=c()
>>> cc.foo()


what will be output ?

OP : A

=============
a=[1,2,3]
>>> b=a
>>> b
[1, 2, 3]
>>> a.append(4)
>>> a
[1, 2, 3, 4]
>>> b
[1, 2, 3, 4]
>>> a=None
what will be output print(b) ?

OP: [1, 2, 3, 4]
=============
what is advantage of generators

Memory is saved as the items are produced when required, unlike normal Python functions. This fact becomes very 
important when you need to create a huge number of iterators

===========
what is partial functions

Partial functions allow us to fix a certain number of arguments of a function and generate a new function.

from functools import partial

# A normal function
def f(a, b, c, x):
	return 1000*a + 100*b + 10*c + x

# A partial function that calls f with
# a as 3, b as 1 and c as 4.
g = partial(f, 3, 1, 4)

# Calling g()
print(g(5))


OP : 3145


from functools import *

# A normal function
def add(a, b, c):
	return 100 * a + 10 * b + c

# A partial function with b = 1 and c = 2
add_part = partial(add, c = 2, b = 1)

# Calling partial function
print(add_part(3))


OP : 312


